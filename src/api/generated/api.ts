/* tslint:disable */
/* eslint-disable */
/**
 * PublicPlus
 * 공공체육시설 활성화 사이트 공공플러스입니다!
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'activity_Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Activity
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {number}
     * @memberof Activity
     */
    'currentParticipants'?: number;
    /**
     * 
     * @type {MeetingBoard}
     * @memberof Activity
     */
    'meetingBoard'?: MeetingBoard;
    /**
     * 
     * @type {Set<ActivityParticipants>}
     * @memberof Activity
     */
    'participants'?: Set<ActivityParticipants>;
}
/**
 * 
 * @export
 * @interface ActivityParticipants
 */
export interface ActivityParticipants {
    /**
     * 
     * @type {number}
     * @memberof ActivityParticipants
     */
    'participantId'?: number;
    /**
     * 
     * @type {Activity}
     * @memberof ActivityParticipants
     */
    'activity'?: Activity;
    /**
     * 
     * @type {User}
     * @memberof ActivityParticipants
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof ActivityParticipants
     */
    'role'?: ActivityParticipantsRoleEnum;
}

export const ActivityParticipantsRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type ActivityParticipantsRoleEnum = typeof ActivityParticipantsRoleEnum[keyof typeof ActivityParticipantsRoleEnum];

/**
 * 
 * @export
 * @interface ActivityRequestDTO
 */
export interface ActivityRequestDTO {
    /**
     * 모임의 제목
     * @type {string}
     * @memberof ActivityRequestDTO
     */
    'title'?: string;
    /**
     * 모임 설명
     * @type {string}
     * @memberof ActivityRequestDTO
     */
    'description'?: string;
    /**
     * 모임 장소
     * @type {string}
     * @memberof ActivityRequestDTO
     */
    'location'?: string;
    /**
     * 모임 시작 시간 (ISO 8601 형식)
     * @type {string}
     * @memberof ActivityRequestDTO
     */
    'startTime'?: string;
    /**
     * 모임 종료 시간 (ISO 8601 형식)
     * @type {string}
     * @memberof ActivityRequestDTO
     */
    'endTime'?: string;
    /**
     * 모임 최대 참석자 수
     * @type {number}
     * @memberof ActivityRequestDTO
     */
    'maxParticipants'?: number;
}
/**
 * 
 * @export
 * @interface ActivityResponseDTO
 */
export interface ActivityResponseDTO {
    /**
     * 모임의 제목입니다
     * @type {string}
     * @memberof ActivityResponseDTO
     */
    'title'?: string;
    /**
     * 모임의 설명입니다
     * @type {string}
     * @memberof ActivityResponseDTO
     */
    'description'?: string;
    /**
     * 모임 지역입니다
     * @type {string}
     * @memberof ActivityResponseDTO
     */
    'location'?: string;
    /**
     * 모임 시작시간입니다  (ISO 8601 로 이루어져있습니다)
     * @type {string}
     * @memberof ActivityResponseDTO
     */
    'startTime'?: string;
    /**
     * 모임 종료시간입니다 (ISO 8601 format)
     * @type {string}
     * @memberof ActivityResponseDTO
     */
    'endTime'?: string;
    /**
     * 최대 참가자 수 입니다
     * @type {number}
     * @memberof ActivityResponseDTO
     */
    'maxParticipants'?: number;
    /**
     * 현재 참가자 수 입니다
     * @type {number}
     * @memberof ActivityResponseDTO
     */
    'currentParticipants'?: number;
}
/**
 * 
 * @export
 * @interface AdminCode
 */
export interface AdminCode {
    /**
     * 
     * @type {number}
     * @memberof AdminCode
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminCode
     */
    'code'?: string;
}
/**
 * 회원가입 요청 데이터
 * @export
 * @interface AdminJoinDTO
 */
export interface AdminJoinDTO {
    /**
     * 관리자 이메일
     * @type {string}
     * @memberof AdminJoinDTO
     */
    'email': string;
    /**
     * 관리자 비밀번호
     * @type {string}
     * @memberof AdminJoinDTO
     */
    'password': string;
    /**
     * 비밀번호 확인
     * @type {string}
     * @memberof AdminJoinDTO
     */
    'checkPassword': string;
    /**
     * 관리자 닉네임
     * @type {string}
     * @memberof AdminJoinDTO
     */
    'nickname': string;
    /**
     * 관리자 가입 확인용 인증코드
     * @type {string}
     * @memberof AdminJoinDTO
     */
    'adminCode': string;
}
/**
 * 
 * @export
 * @interface BoardFilterDTO
 */
export interface BoardFilterDTO {
    /**
     * 
     * @type {string}
     * @memberof BoardFilterDTO
     */
    '타이틀'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardFilterDTO
     */
    '장소'?: string;
    /**
     * Enum에서 영어로 BADMINTON,SOCCER ... 으로 되어있습니다
     * @type {string}
     * @memberof BoardFilterDTO
     */
    '스포츠 타입'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDTO
 */
export interface ChangePasswordDTO {
    /**
     * 사용자 이메일
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'email': string;
    /**
     * 변경할 비밀번호
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'changePassword': string;
    /**
     * 변경할 비밀번호 확인
     * @type {string}
     * @memberof ChangePasswordDTO
     */
    'checkChangePassword': string;
}
/**
 * 
 * @export
 * @interface ChatParticipant
 */
export interface ChatParticipant {
    /**
     * 
     * @type {number}
     * @memberof ChatParticipant
     */
    'participantId'?: number;
    /**
     * 
     * @type {ChatRoom}
     * @memberof ChatParticipant
     */
    'chatRoom'?: ChatRoom;
    /**
     * 
     * @type {User}
     * @memberof ChatParticipant
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatParticipant
     */
    'role'?: ChatParticipantRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ChatParticipant
     */
    'host'?: boolean;
}

export const ChatParticipantRoleEnum = {
    Host: 'HOST',
    Member: 'MEMBER'
} as const;

export type ChatParticipantRoleEnum = typeof ChatParticipantRoleEnum[keyof typeof ChatParticipantRoleEnum];

/**
 * 채팅방 참가자 응답 DTO
 * @export
 * @interface ChatParticipantResponseDTO
 */
export interface ChatParticipantResponseDTO {
    /**
     * 참가자 ID
     * @type {number}
     * @memberof ChatParticipantResponseDTO
     */
    'participantId'?: number;
    /**
     * 유저 ID
     * @type {string}
     * @memberof ChatParticipantResponseDTO
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ChatRoom
 */
export interface ChatRoom {
    /**
     * 
     * @type {number}
     * @memberof ChatRoom
     */
    'chatRoomId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'type'?: ChatRoomTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'startTime'?: string;
    /**
     * 
     * @type {Array<ChatParticipant>}
     * @memberof ChatRoom
     */
    'chatParticipants'?: Array<ChatParticipant>;
    /**
     * 
     * @type {Array<Message>}
     * @memberof ChatRoom
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatRoom
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChatRoom
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChatRoom
     */
    'deleted'?: boolean;
}

export const ChatRoomTypeEnum = {
    Group: 'GROUP',
    Private: 'PRIVATE'
} as const;

export type ChatRoomTypeEnum = typeof ChatRoomTypeEnum[keyof typeof ChatRoomTypeEnum];

/**
 * 채팅방 생성 요청 DTO
 * @export
 * @interface ChatRoomRequestDTO
 */
export interface ChatRoomRequestDTO {
    /**
     * 채팅방 이름
     * @type {string}
     * @memberof ChatRoomRequestDTO
     */
    'chatRoomName': string;
    /**
     * 채팅방 타입 (GROUP 또는 PRIVATE)
     * @type {string}
     * @memberof ChatRoomRequestDTO
     */
    'chatRoomType': string;
    /**
     * 채팅방 최대 참여 인원 (1대1 채팅 시 2)
     * @type {number}
     * @memberof ChatRoomRequestDTO
     */
    'maxParticipants'?: number;
}
/**
 * 채팅방 응답 DTO
 * @export
 * @interface ChatRoomResponseDTO
 */
export interface ChatRoomResponseDTO {
    /**
     * 채팅방 ID
     * @type {number}
     * @memberof ChatRoomResponseDTO
     */
    'chatRoomId'?: number;
    /**
     * 채팅방 이름
     * @type {string}
     * @memberof ChatRoomResponseDTO
     */
    'chatRoomName'?: string;
    /**
     * 채팅방 타입 (GROUP 또는 PRIVATE)
     * @type {string}
     * @memberof ChatRoomResponseDTO
     */
    'chatRoomType'?: string;
    /**
     * 채팅방 생성 시간
     * @type {string}
     * @memberof ChatRoomResponseDTO
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface ClassInfo
 */
export interface ClassInfo {
    /**
     * 
     * @type {boolean}
     * @memberof ClassInfo
     */
    'ignoreCase'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassInfo
     */
    'names'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ClassInfo
     */
    'enum'?: boolean;
    /**
     * 
     * @type {Array<FieldInfo>}
     * @memberof ClassInfo
     */
    'fieldInfos'?: Array<FieldInfo>;
}
/**
 * 
 * @export
 * @interface DateTime
 */
export interface DateTime {
    /**
     * 
     * @type {number}
     * @memberof DateTime
     */
    'value'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DateTime
     */
    'dateOnly'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DateTime
     */
    'timeZoneShift'?: number;
}
/**
 * 
 * @export
 * @interface EntryPoint
 */
export interface EntryPoint {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EntryPoint
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'accessCode'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EntryPoint
     */
    'entryPointFeatures'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'entryPointType'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'meetingCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'passcode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'pin'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'regionCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntryPoint
     */
    'uri'?: string;
    /**
     * 
     * @type {object}
     * @memberof EntryPoint
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EntryPoint
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EntryPoint
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'httpStatus'?: ErrorResponseHttpStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message'?: string;
}

export const ErrorResponseHttpStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ErrorResponseHttpStatusEnum = typeof ErrorResponseHttpStatusEnum[keyof typeof ErrorResponseHttpStatusEnum];

/**
 * 
 * @export
 * @interface ErrorResponseDTO
 */
export interface ErrorResponseDTO {
    /**
     * 에러 코드
     * @type {string}
     * @memberof ErrorResponseDTO
     */
    'errorCode'?: string;
    /**
     * 에러 메시지
     * @type {string}
     * @memberof ErrorResponseDTO
     */
    'message'?: string;
    /**
     * 에러에 대한 세부 설명
     * @type {string}
     * @memberof ErrorResponseDTO
     */
    'details'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof Event
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'anyoneCanAddSelf'?: boolean;
    /**
     * 
     * @type {Array<EventAttachment>}
     * @memberof Event
     */
    'attachments'?: Array<EventAttachment>;
    /**
     * 
     * @type {Array<EventAttendee>}
     * @memberof Event
     */
    'attendees'?: Array<EventAttendee>;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'attendeesOmitted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'colorId'?: string;
    /**
     * 
     * @type {EventConferenceData}
     * @memberof Event
     */
    'conferenceData'?: EventConferenceData;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'created'?: string;
    /**
     * 
     * @type {EventCreator}
     * @memberof Event
     */
    'creator'?: EventCreator;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'description'?: string;
    /**
     * 
     * @type {EventEnd}
     * @memberof Event
     */
    'end'?: EventEnd;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'endTimeUnspecified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'etag'?: string;
    /**
     * 
     * @type {EventExtendedProperties}
     * @memberof Event
     */
    'extendedProperties'?: EventExtendedProperties;
    /**
     * 
     * @type {EventGadget}
     * @memberof Event
     */
    'gadget'?: EventGadget;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'guestsCanInviteOthers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'guestsCanModify'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'guestsCanSeeOtherGuests'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'hangoutLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'htmlLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'locked'?: boolean;
    /**
     * 
     * @type {EventCreator}
     * @memberof Event
     */
    'organizer'?: EventCreator;
    /**
     * 
     * @type {EventEnd}
     * @memberof Event
     */
    'originalStartTime'?: EventEnd;
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'privateCopy'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Event
     */
    'recurrence'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'recurringEventId'?: string;
    /**
     * 
     * @type {EventReminders}
     * @memberof Event
     */
    'reminders'?: EventReminders;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'sequence'?: number;
    /**
     * 
     * @type {EventSource}
     * @memberof Event
     */
    'source'?: EventSource;
    /**
     * 
     * @type {EventEnd}
     * @memberof Event
     */
    'start'?: EventEnd;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'transparency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'visibility'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'icalUID'?: string;
    /**
     * 
     * @type {object}
     * @memberof Event
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Event
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof Event
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventAttachment
 */
export interface EventAttachment {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventAttachment
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventAttachment
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttachment
     */
    'fileUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttachment
     */
    'iconLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttachment
     */
    'mimeType'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttachment
     */
    'title'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventAttachment
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventAttachment
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventAttachment
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventAttendee
 */
export interface EventAttendee {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventAttendee
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {number}
     * @memberof EventAttendee
     */
    'additionalGuests'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventAttendee
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttendee
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttendee
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventAttendee
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventAttendee
     */
    'optional'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventAttendee
     */
    'organizer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventAttendee
     */
    'resource'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventAttendee
     */
    'responseStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventAttendee
     */
    'self'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof EventAttendee
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventAttendee
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventAttendee
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceData
 */
export interface EventConferenceData {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceData
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceData
     */
    'conferenceId'?: string;
    /**
     * 
     * @type {EventConferenceDataConferenceSolution}
     * @memberof EventConferenceData
     */
    'conferenceSolution'?: EventConferenceDataConferenceSolution;
    /**
     * 
     * @type {EventConferenceDataCreateRequest}
     * @memberof EventConferenceData
     */
    'createRequest'?: EventConferenceDataCreateRequest;
    /**
     * 
     * @type {Array<EntryPoint>}
     * @memberof EventConferenceData
     */
    'entryPoints'?: Array<EntryPoint>;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceData
     */
    'notes'?: string;
    /**
     * 
     * @type {EventConferenceDataParameters}
     * @memberof EventConferenceData
     */
    'parameters'?: EventConferenceDataParameters;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceData
     */
    'signature'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceData
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceData
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceData
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataConferenceSolution
 */
export interface EventConferenceDataConferenceSolution {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataConferenceSolution
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceDataConferenceSolution
     */
    'iconUri'?: string;
    /**
     * 
     * @type {EventConferenceDataConferenceSolutionKey}
     * @memberof EventConferenceDataConferenceSolution
     */
    'key'?: EventConferenceDataConferenceSolutionKey;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceDataConferenceSolution
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataConferenceSolution
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataConferenceSolution
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataConferenceSolution
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataConferenceSolutionKey
 */
export interface EventConferenceDataConferenceSolutionKey {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataConferenceSolutionKey
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceDataConferenceSolutionKey
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataConferenceSolutionKey
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataConferenceSolutionKey
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataConferenceSolutionKey
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataCreateRequest
 */
export interface EventConferenceDataCreateRequest {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataCreateRequest
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {EventConferenceDataConferenceSolutionKey}
     * @memberof EventConferenceDataCreateRequest
     */
    'conferenceSolutionKey'?: EventConferenceDataConferenceSolutionKey;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceDataCreateRequest
     */
    'requestId'?: string;
    /**
     * 
     * @type {EventConferenceDataCreateRequestStatus}
     * @memberof EventConferenceDataCreateRequest
     */
    'status'?: EventConferenceDataCreateRequestStatus;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataCreateRequest
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataCreateRequest
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataCreateRequest
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataCreateRequestStatus
 */
export interface EventConferenceDataCreateRequestStatus {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataCreateRequestStatus
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventConferenceDataCreateRequestStatus
     */
    'statusCode'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataCreateRequestStatus
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataCreateRequestStatus
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataCreateRequestStatus
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataParameters
 */
export interface EventConferenceDataParameters {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataParameters
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {EventConferenceDataParametersAddOnParameters}
     * @memberof EventConferenceDataParameters
     */
    'addOnParameters'?: EventConferenceDataParametersAddOnParameters;
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataParameters
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataParameters
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataParameters
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventConferenceDataParametersAddOnParameters
 */
export interface EventConferenceDataParametersAddOnParameters {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventConferenceDataParametersAddOnParameters
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EventConferenceDataParametersAddOnParameters
     */
    'parameters'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof EventConferenceDataParametersAddOnParameters
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventConferenceDataParametersAddOnParameters
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventConferenceDataParametersAddOnParameters
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventCreator
 */
export interface EventCreator {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventCreator
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventCreator
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreator
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreator
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventCreator
     */
    'self'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof EventCreator
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventCreator
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventCreator
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventEnd
 */
export interface EventEnd {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventEnd
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventEnd
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventEnd
     */
    'dateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventEnd
     */
    'timeZone'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventEnd
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventEnd
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventEnd
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventExtendedProperties
 */
export interface EventExtendedProperties {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventExtendedProperties
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EventExtendedProperties
     */
    'shared'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EventExtendedProperties
     */
    'private'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof EventExtendedProperties
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventExtendedProperties
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventExtendedProperties
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventGadget
 */
export interface EventGadget {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventGadget
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventGadget
     */
    'display'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventGadget
     */
    'height'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventGadget
     */
    'iconLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGadget
     */
    'link'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EventGadget
     */
    'preferences'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof EventGadget
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventGadget
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventGadget
     */
    'width'?: number;
    /**
     * 
     * @type {object}
     * @memberof EventGadget
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventGadget
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventGadget
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventReminder
 */
export interface EventReminder {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventReminder
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventReminder
     */
    'method'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventReminder
     */
    'minutes'?: number;
    /**
     * 
     * @type {object}
     * @memberof EventReminder
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventReminder
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventReminder
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventReminders
 */
export interface EventReminders {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventReminders
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {Array<EventReminder>}
     * @memberof EventReminders
     */
    'overrides'?: Array<EventReminder>;
    /**
     * 
     * @type {boolean}
     * @memberof EventReminders
     */
    'useDefault'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof EventReminders
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventReminders
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventReminders
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface EventSource
 */
export interface EventSource {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof EventSource
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof EventSource
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSource
     */
    'url'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventSource
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EventSource
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EventSource
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface Events
 */
export interface Events {
    [key: string]: object | any;

    /**
     * 
     * @type {ClassInfo}
     * @memberof Events
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'accessRole'?: string;
    /**
     * 
     * @type {Array<EventReminder>}
     * @memberof Events
     */
    'defaultReminders'?: Array<EventReminder>;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'etag'?: string;
    /**
     * 
     * @type {Array<Event>}
     * @memberof Events
     */
    'items'?: Array<Event>;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'kind'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'nextPageToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'nextSyncToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'timeZone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Events
     */
    'updated'?: string;
    /**
     * 
     * @type {object}
     * @memberof Events
     */
    'factory'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Events
     */
    'unknownKeys'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof Events
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface FacilityDetailsResponseDTO
 */
export interface FacilityDetailsResponseDTO {
    /**
     * 시설 고유 ID
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityId'?: string;
    /**
     * 시설 이름
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityName'?: string;
    /**
     * 시설 카테고리
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityCategory'?: FacilityDetailsResponseDTOFacilityCategoryEnum;
    /**
     * 시설 지역
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'area'?: string;
    /**
     * 무료/유료 여부
     * @type {boolean}
     * @memberof FacilityDetailsResponseDTO
     */
    'priceType'?: boolean;
    /**
     * 시설 이미지 URL
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityImage'?: string;
    /**
     * 예약 시작 날짜
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'reservationStartDate'?: string;
    /**
     * 예약 종료 날짜
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'reservationEndDate'?: string;
    /**
     * 시설 전화번호
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityNumber'?: string;
    /**
     * 시설 예약 URL
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'reservationURL'?: string;
    /**
     * 시설 상세 주소
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityLocation'?: string;
    /**
     * 시설 설명
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'facilityDescription'?: string;
    /**
     * 서비스 시작 날짜
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'serviceStartDate'?: string;
    /**
     * 서비스 종료 날짜
     * @type {string}
     * @memberof FacilityDetailsResponseDTO
     */
    'serviceEndDate'?: string;
    /**
     * 위도
     * @type {number}
     * @memberof FacilityDetailsResponseDTO
     */
    'latitude'?: number;
    /**
     * 경도
     * @type {number}
     * @memberof FacilityDetailsResponseDTO
     */
    'longitude'?: number;
    /**
     * 좋아요 확인
     * @type {boolean}
     * @memberof FacilityDetailsResponseDTO
     */
    'liked'?: boolean;
    /**
     * 좋아요 개수
     * @type {number}
     * @memberof FacilityDetailsResponseDTO
     */
    'likeCount'?: number;
    /**
     * 조회수
     * @type {number}
     * @memberof FacilityDetailsResponseDTO
     */
    'views'?: number;
}

export const FacilityDetailsResponseDTOFacilityCategoryEnum = {
    FootballField: 'FOOTBALL_FIELD',
    FutsalField: 'FUTSAL_FIELD',
    FootVolleyballField: 'FOOT_VOLLEYBALL_FIELD',
    BaseballField: 'BASEBALL_FIELD',
    TennisField: 'TENNIS_FIELD',
    BasketballField: 'BASKETBALL_FIELD',
    VolleyballField: 'VOLLEYBALL_FIELD',
    MultipurposeField: 'MULTIPURPOSE_FIELD',
    SportsField: 'SPORTS_FIELD',
    Gym: 'GYM',
    BadmintonField: 'BADMINTON_FIELD',
    TableTennisField: 'TABLE_TENNIS_FIELD',
    EducationalFacility: 'EDUCATIONAL_FACILITY',
    SwimmingPool: 'SWIMMING_POOL',
    GolfField: 'GOLF_FIELD'
} as const;

export type FacilityDetailsResponseDTOFacilityCategoryEnum = typeof FacilityDetailsResponseDTOFacilityCategoryEnum[keyof typeof FacilityDetailsResponseDTOFacilityCategoryEnum];

/**
 * 
 * @export
 * @interface FacilityDetailsUpdateDTO
 */
export interface FacilityDetailsUpdateDTO {
    /**
     * 시설 고유 ID
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityId'?: string;
    /**
     * 시설 이름
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityName'?: string;
    /**
     * 시설 카테고리
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityCategory'?: FacilityDetailsUpdateDTOFacilityCategoryEnum;
    /**
     * 시설 지역
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'area'?: string;
    /**
     * 무료(true) / 유료(false)
     * @type {boolean}
     * @memberof FacilityDetailsUpdateDTO
     */
    'priceType'?: boolean;
    /**
     * 시설 이미지 URL
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityImage'?: string;
    /**
     * 서비스 시작 날짜
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'reservationStartDate'?: string;
    /**
     * 서비스 종료 날짜
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'reservationEndDate'?: string;
    /**
     * 시설 전화번호
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityNumber'?: string;
    /**
     * 예약 URL
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'reservationURL'?: string;
    /**
     * 시설 상세 주소
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityLocation'?: string;
    /**
     * 시설 설명
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'facilityDescription'?: string;
    /**
     * 서비스 시작 날짜 (String 형식)
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'serviceStartDate'?: string;
    /**
     * 서비스 종료 날짜 (String 형식)
     * @type {string}
     * @memberof FacilityDetailsUpdateDTO
     */
    'serviceEndDate'?: string;
}

export const FacilityDetailsUpdateDTOFacilityCategoryEnum = {
    FootballField: 'FOOTBALL_FIELD',
    FutsalField: 'FUTSAL_FIELD',
    FootVolleyballField: 'FOOT_VOLLEYBALL_FIELD',
    BaseballField: 'BASEBALL_FIELD',
    TennisField: 'TENNIS_FIELD',
    BasketballField: 'BASKETBALL_FIELD',
    VolleyballField: 'VOLLEYBALL_FIELD',
    MultipurposeField: 'MULTIPURPOSE_FIELD',
    SportsField: 'SPORTS_FIELD',
    Gym: 'GYM',
    BadmintonField: 'BADMINTON_FIELD',
    TableTennisField: 'TABLE_TENNIS_FIELD',
    EducationalFacility: 'EDUCATIONAL_FACILITY',
    SwimmingPool: 'SWIMMING_POOL',
    GolfField: 'GOLF_FIELD'
} as const;

export type FacilityDetailsUpdateDTOFacilityCategoryEnum = typeof FacilityDetailsUpdateDTOFacilityCategoryEnum[keyof typeof FacilityDetailsUpdateDTOFacilityCategoryEnum];

/**
 * 
 * @export
 * @interface FacilityFilterDTO
 */
export interface FacilityFilterDTO {
    /**
     * 시설 이름
     * @type {string}
     * @memberof FacilityFilterDTO
     */
    'facilityName'?: string;
    /**
     * 시설 카테고리
     * @type {string}
     * @memberof FacilityFilterDTO
     */
    'facilityCategory'?: string;
    /**
     * 시설 지역
     * @type {string}
     * @memberof FacilityFilterDTO
     */
    'area'?: string;
    /**
     * 시설 가격 유형(무료/유료)
     * @type {boolean}
     * @memberof FacilityFilterDTO
     */
    'priceType'?: boolean;
    /**
     * 좋아요 정렬 기준 (0: 정렬 없음, 1: 내림차순, 2: 오름차순)
     * @type {number}
     * @memberof FacilityFilterDTO
     */
    'likeOrder'?: number;
    /**
     * 조회수 정렬 기준(0): 정렬 없음, 1:내림차순, 2:오름차순
     * @type {number}
     * @memberof FacilityFilterDTO
     */
    'viewsOrder'?: number;
}
/**
 * 
 * @export
 * @interface FacilityLocationDTO
 */
export interface FacilityLocationDTO {
    /**
     * 검색할 시설의 위도
     * @type {number}
     * @memberof FacilityLocationDTO
     */
    'latitude'?: number;
    /**
     * 검색할 시설의 경도
     * @type {number}
     * @memberof FacilityLocationDTO
     */
    'longitude'?: number;
    /**
     * 검색할 반경 (킬로미터 단위)
     * @type {number}
     * @memberof FacilityLocationDTO
     */
    'radius'?: number;
}
/**
 * 
 * @export
 * @interface FieldInfo
 */
export interface FieldInfo {
    /**
     * 
     * @type {FieldInfoField}
     * @memberof FieldInfo
     */
    'field'?: FieldInfoField;
    /**
     * 
     * @type {string}
     * @memberof FieldInfo
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfo
     */
    'primitive'?: boolean;
    /**
     * 
     * @type {FieldInfoFieldGenericType}
     * @memberof FieldInfo
     */
    'genericType'?: FieldInfoFieldGenericType;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfo
     */
    'final'?: boolean;
    /**
     * 
     * @type {ClassInfo}
     * @memberof FieldInfo
     */
    'classInfo'?: ClassInfo;
    /**
     * 
     * @type {Array<FieldInfoTersMethodForField>}
     * @memberof FieldInfo
     */
    'tersMethodForField'?: Array<FieldInfoTersMethodForField>;
}
/**
 * 
 * @export
 * @interface FieldInfoDeclaringExecutable
 */
export interface FieldInfoDeclaringExecutable {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoDeclaringExecutable
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoDeclaringExecutable
     */
    'modifiers'?: number;
    /**
     * 
     * @type {Array<FieldInfoDeclaringExecutableTypeParameters>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'typeParameters'?: Array<FieldInfoDeclaringExecutableTypeParameters>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoDeclaringExecutable
     */
    'synthetic'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoDeclaringExecutable
     */
    'varArgs'?: boolean;
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'annotatedParameterTypes'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoDeclaringExecutable
     */
    'parameterCount'?: number;
    /**
     * 
     * @type {Array<Array<object>>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'parameterAnnotations'?: Array<Array<object>>;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'genericParameterTypes'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'genericExceptionTypes'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoDeclaringExecutable
     */
    'annotatedReturnType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoDeclaringExecutable
     */
    'annotatedReceiverType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'annotatedExceptionTypes'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoDeclaringExecutable
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoDeclaringExecutable
     * @deprecated
     */
    'accessible'?: boolean;
}
/**
 * 
 * @export
 * @interface FieldInfoDeclaringExecutableTypeParameters
 */
export interface FieldInfoDeclaringExecutableTypeParameters {
    /**
     * 
     * @type {object}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'genericDeclaration'?: object;
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'annotatedBounds'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'name'?: string;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'bounds'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'typeName'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoDeclaringExecutableTypeParameters
     */
    'declaredAnnotations'?: Array<object>;
}
/**
 * 
 * @export
 * @interface FieldInfoField
 */
export interface FieldInfoField {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoField
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoField
     */
    'modifiers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoField
     */
    'synthetic'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoField
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoField
     * @deprecated
     */
    'accessible'?: boolean;
    /**
     * 
     * @type {FieldInfoFieldGenericType}
     * @memberof FieldInfoField
     */
    'genericType'?: FieldInfoFieldGenericType;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoField
     */
    'enumConstant'?: boolean;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoField
     */
    'annotatedType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoField
     */
    'annotations'?: Array<object>;
}
/**
 * 
 * @export
 * @interface FieldInfoFieldAnnotatedType
 */
export interface FieldInfoFieldAnnotatedType {
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoFieldAnnotatedType
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoFieldAnnotatedType
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {FieldInfoFieldGenericType}
     * @memberof FieldInfoFieldAnnotatedType
     */
    'type'?: FieldInfoFieldGenericType;
}
/**
 * 
 * @export
 * @interface FieldInfoFieldGenericType
 */
export interface FieldInfoFieldGenericType {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoFieldGenericType
     */
    'typeName'?: string;
}
/**
 * 
 * @export
 * @interface FieldInfoParameters
 */
export interface FieldInfoParameters {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoParameters
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoParameters
     */
    'modifiers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoParameters
     */
    'synthetic'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoParameters
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoParameters
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoParameters
     */
    'annotatedType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {FieldInfoFieldGenericType}
     * @memberof FieldInfoParameters
     */
    'parameterizedType'?: FieldInfoFieldGenericType;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoParameters
     */
    'varArgs'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoParameters
     */
    'namePresent'?: boolean;
    /**
     * 
     * @type {FieldInfoDeclaringExecutable}
     * @memberof FieldInfoParameters
     */
    'declaringExecutable'?: FieldInfoDeclaringExecutable;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoParameters
     */
    'implicit'?: boolean;
}
/**
 * 
 * @export
 * @interface FieldInfoTersMethodForField
 */
export interface FieldInfoTersMethodForField {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoTersMethodForField
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoTersMethodForField
     */
    'modifiers'?: number;
    /**
     * 
     * @type {Array<FieldInfoTypeParameters>}
     * @memberof FieldInfoTersMethodForField
     */
    'typeParameters'?: Array<FieldInfoTypeParameters>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoTersMethodForField
     */
    'synthetic'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoTersMethodForField
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoTersMethodForField
     * @deprecated
     */
    'accessible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoTersMethodForField
     */
    'varArgs'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoTersMethodForField
     */
    'parameterCount'?: number;
    /**
     * 
     * @type {Array<Array<object>>}
     * @memberof FieldInfoTersMethodForField
     */
    'parameterAnnotations'?: Array<Array<object>>;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoTersMethodForField
     */
    'genericParameterTypes'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoTersMethodForField
     */
    'genericExceptionTypes'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoTersMethodForField
     */
    'default'?: boolean;
    /**
     * 
     * @type {FieldInfoFieldGenericType}
     * @memberof FieldInfoTersMethodForField
     */
    'genericReturnType'?: FieldInfoFieldGenericType;
    /**
     * 
     * @type {boolean}
     * @memberof FieldInfoTersMethodForField
     */
    'bridge'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof FieldInfoTersMethodForField
     */
    'defaultValue'?: object;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoTersMethodForField
     */
    'annotatedReturnType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoTersMethodForField
     */
    'annotatedParameterTypes'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {Array<FieldInfoParameters>}
     * @memberof FieldInfoTersMethodForField
     */
    'parameters'?: Array<FieldInfoParameters>;
    /**
     * 
     * @type {FieldInfoFieldAnnotatedType}
     * @memberof FieldInfoTersMethodForField
     */
    'annotatedReceiverType'?: FieldInfoFieldAnnotatedType;
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoTersMethodForField
     */
    'annotatedExceptionTypes'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoTersMethodForField
     */
    'annotations'?: Array<object>;
}
/**
 * 
 * @export
 * @interface FieldInfoTypeParameters
 */
export interface FieldInfoTypeParameters {
    /**
     * 
     * @type {Array<FieldInfoFieldAnnotatedType>}
     * @memberof FieldInfoTypeParameters
     */
    'annotatedBounds'?: Array<FieldInfoFieldAnnotatedType>;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoTypeParameters
     */
    'name'?: string;
    /**
     * 
     * @type {Array<FieldInfoFieldGenericType>}
     * @memberof FieldInfoTypeParameters
     */
    'bounds'?: Array<FieldInfoFieldGenericType>;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoTypeParameters
     */
    'typeName'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoTypeParameters
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldInfoTypeParameters
     */
    'declaredAnnotations'?: Array<object>;
}
/**
 * 
 * @export
 * @interface JwtToken
 */
export interface JwtToken {
    /**
     * 인증 통신을 위한 bearer 고정값
     * @type {string}
     * @memberof JwtToken
     */
    'authentication'?: string;
    /**
     * 사이트 권한을 위한 access token
     * @type {string}
     * @memberof JwtToken
     */
    'accessToken'?: string;
    /**
     * access token 재발급을 위한 refresh token
     * @type {string}
     * @memberof JwtToken
     */
    'refreshToken'?: string;
    /**
     * 사용자 고유번호
     * @type {string}
     * @memberof JwtToken
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface MeetingBoard
 */
export interface MeetingBoard {
    /**
     * 
     * @type {number}
     * @memberof MeetingBoard
     */
    'mbId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'sportType'?: MeetingBoardSportTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbLocation'?: string;
    /**
     * 
     * @type {User}
     * @memberof MeetingBoard
     */
    'mbHost'?: User;
    /**
     * 
     * @type {number}
     * @memberof MeetingBoard
     */
    'maxParticipants'?: number;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbCreatedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbLastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof MeetingBoard
     */
    'mbDeletedDate'?: string;
    /**
     * 
     * @type {Activity}
     * @memberof MeetingBoard
     */
    'activity'?: Activity;
}

export const MeetingBoardSportTypeEnum = {
    Badminton: 'BADMINTON',
    Baseball: 'BASEBALL',
    Basketball: 'BASKETBALL',
    Soccer: 'SOCCER',
    Swimming: 'SWIMMING',
    Tennis: 'TENNIS'
} as const;

export type MeetingBoardSportTypeEnum = typeof MeetingBoardSportTypeEnum[keyof typeof MeetingBoardSportTypeEnum];

/**
 * 모임 게시판 요청 DTO
 * @export
 * @interface MeetingBoardRequestDTO
 */
export interface MeetingBoardRequestDTO {
    /**
     * 운동 종목 (예: SOCCER, BASEBALL)
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'sportType': MeetingBoardRequestDTOSportTypeEnum;
    /**
     * 모임 제목
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'mbTitle': string;
    /**
     * 모임 내용
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'mbContent': string;
    /**
     * 모임 시작 시간
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'startTime': string;
    /**
     * 모임 종료 시간
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'endTime': string;
    /**
     * 모임 장소
     * @type {string}
     * @memberof MeetingBoardRequestDTO
     */
    'mbLocation': string;
    /**
     * 최대 참여자 수
     * @type {number}
     * @memberof MeetingBoardRequestDTO
     */
    'maxParticipants': number;
}

export const MeetingBoardRequestDTOSportTypeEnum = {
    Badminton: 'BADMINTON',
    Baseball: 'BASEBALL',
    Basketball: 'BASKETBALL',
    Soccer: 'SOCCER',
    Swimming: 'SWIMMING',
    Tennis: 'TENNIS'
} as const;

export type MeetingBoardRequestDTOSportTypeEnum = typeof MeetingBoardRequestDTOSportTypeEnum[keyof typeof MeetingBoardRequestDTOSportTypeEnum];

/**
 * 모임 게시판 응답 DTO
 * @export
 * @interface MeetingBoardResponseDTO
 */
export interface MeetingBoardResponseDTO {
    /**
     * 모임 게시판 ID
     * @type {number}
     * @memberof MeetingBoardResponseDTO
     */
    'mbId'?: number;
    /**
     * 운동 종목 (예: SOCCER, BASEBALL)
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'sportType'?: MeetingBoardResponseDTOSportTypeEnum;
    /**
     * 모임 제목
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbTitle'?: string;
    /**
     * 모임 내용
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbContent'?: string;
    /**
     * 모임 시작 시간
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'startTime'?: string;
    /**
     * 모임 종료 시간
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'endTime'?: string;
    /**
     * 모임 장소
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbLocation'?: string;
    /**
     * 최대 참여자 수
     * @type {number}
     * @memberof MeetingBoardResponseDTO
     */
    'maxParticipants'?: number;
    /**
     * 생성 일자
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbCreatedDate'?: string;
    /**
     * 마지막 수정 일자
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbLastModifiedDate'?: string;
    /**
     * 모임 주최자 ID
     * @type {string}
     * @memberof MeetingBoardResponseDTO
     */
    'mbHostId'?: string;
}

export const MeetingBoardResponseDTOSportTypeEnum = {
    Badminton: 'BADMINTON',
    Baseball: 'BASEBALL',
    Basketball: 'BASKETBALL',
    Soccer: 'SOCCER',
    Swimming: 'SWIMMING',
    Tennis: 'TENNIS'
} as const;

export type MeetingBoardResponseDTOSportTypeEnum = typeof MeetingBoardResponseDTOSportTypeEnum[keyof typeof MeetingBoardResponseDTOSportTypeEnum];

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'messageId'?: number;
    /**
     * 
     * @type {ChatRoom}
     * @memberof Message
     */
    'chatRoom'?: ChatRoom;
    /**
     * 
     * @type {ChatParticipant}
     * @memberof Message
     */
    'participant'?: ChatParticipant;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'sentAt'?: string;
}
/**
 * 메시지 요청 DTO
 * @export
 * @interface MessageRequestDTO
 */
export interface MessageRequestDTO {
    /**
     * 채팅방 ID
     * @type {number}
     * @memberof MessageRequestDTO
     */
    'chatRoomId': number;
    /**
     * 참가자 ID
     * @type {number}
     * @memberof MessageRequestDTO
     */
    'participantId': number;
    /**
     * 메시지 내용
     * @type {string}
     * @memberof MessageRequestDTO
     */
    'content': string;
}
/**
 * 메시지 응답 DTO
 * @export
 * @interface MessageResponseDTO
 */
export interface MessageResponseDTO {
    /**
     * 메시지 ID
     * @type {number}
     * @memberof MessageResponseDTO
     */
    'messageId'?: number;
    /**
     * 메시지 내용
     * @type {string}
     * @memberof MessageResponseDTO
     */
    'content'?: string;
    /**
     * 보낸 사람 닉네임
     * @type {string}
     * @memberof MessageResponseDTO
     */
    'sender'?: string;
    /**
     * 채팅방 ID
     * @type {number}
     * @memberof MessageResponseDTO
     */
    'chatRoomId'?: number;
    /**
     * 메시지 전송 시간
     * @type {string}
     * @memberof MessageResponseDTO
     */
    'sentAt'?: string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'notification_Id'?: number;
    /**
     * 
     * @type {User}
     * @memberof Notification
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'notificationTitleType'?: NotificationNotificationTitleTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'createdDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Notification
     */
    'read'?: boolean;
}

export const NotificationNotificationTitleTypeEnum = {
    ChatNewMessage: 'CHAT_NEW_MESSAGE',
    ActivityReminder: 'ACTIVITY_REMINDER',
    ActivityInvited: 'ACTIVITY_INVITED',
    ActivityParticipate: 'ACTIVITY_PARTICIPATE'
} as const;

export type NotificationNotificationTitleTypeEnum = typeof NotificationNotificationTitleTypeEnum[keyof typeof NotificationNotificationTitleTypeEnum];

/**
 * 
 * @export
 * @interface NotificationCreateDTO
 */
export interface NotificationCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof NotificationCreateDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreateDTO
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationCreateDTO
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface NotificationDTO
 */
export interface NotificationDTO {
    /**
     * 
     * @type {number}
     * @memberof NotificationDTO
     */
    'notificationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDTO
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationDTO
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface Oauth
 */
export interface Oauth {
    /**
     * 
     * @type {number}
     * @memberof Oauth
     */
    'oauthId'?: number;
    /**
     * 
     * @type {User}
     * @memberof Oauth
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Oauth
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth
     */
    'providerId'?: string;
}
/**
 * 
 * @export
 * @interface PageMetadata
 */
export interface PageMetadata {
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMetadata
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    'sort'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PagedModel
 */
export interface PagedModel {
    /**
     * 
     * @type {Array<object>}
     * @memberof PagedModel
     */
    'content'?: Array<object>;
    /**
     * 
     * @type {PageMetadata}
     * @memberof PagedModel
     */
    'page'?: PageMetadata;
}
/**
 * 
 * @export
 * @interface ReviewDTO
 */
export interface ReviewDTO {
    /**
     * 
     * @type {number}
     * @memberof ReviewDTO
     */
    'reviewId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewDTO
     */
    'facilityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewDTO
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReviewDTO
     */
    'rating'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReviewDTO
     */
    'tags'?: Array<ReviewDTOTagsEnum>;
    /**
     * 
     * @type {number}
     * @memberof ReviewDTO
     */
    'likes'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReviewDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReviewDTO
     */
    'updatedAt'?: string;
}

export const ReviewDTOTagsEnum = {
    Yangcheon: 'YANGCHEON',
    Gangseo: 'GANGSEO',
    Guro: 'GURO',
    Geumcheon: 'GEUMCHEON',
    Gwanak: 'GWANAK',
    Dongjak: 'DONGJAK',
    Seocho: 'SEOCHO',
    Gangnam: 'GANGNAM',
    Songpa: 'SONGPA',
    Gangdong: 'GANGDONG',
    Gwangjin: 'GWANGJIN',
    Seongdong: 'SEONGDONG',
    Junggu: 'JUNGGU',
    Yongsan: 'YONGSAN',
    Yeongdeungpo: 'YEONGDEUNGPO',
    Mapo: 'MAPO',
    Seodaemun: 'SEODAEMUN',
    Eunpyeong: 'EUNPYEONG',
    Jongno: 'JONGNO',
    Dongdaemun: 'DONGDAEMUN',
    Seongbuk: 'SEONGBUK',
    Jungrang: 'JUNGRANG',
    Nowon: 'NOWON',
    Dobong: 'DOBONG',
    Gangbuk: 'GANGBUK',
    Tennis: 'TENNIS',
    Basketball: 'BASKETBALL',
    Football: 'FOOTBALL',
    Futsal: 'FUTSAL',
    Baseball: 'BASEBALL',
    Volleyball: 'VOLLEYBALL',
    Pingpong: 'PINGPONG',
    Badminton: 'BADMINTON',
    Bowling: 'BOWLING',
    Swimming: 'SWIMMING',
    Hockey: 'HOCKEY',
    Golf: 'GOLF',
    Etc: 'ETC',
    Clean: 'CLEAN',
    Spacious: 'SPACIOUS',
    Free: 'FREE',
    Cafe: 'CAFE',
    GoodLocation: 'GOOD_LOCATION',
    EasyReservation: 'EASY_RESERVATION',
    LargeReservation: 'LARGE_RESERVATION',
    ModernEquipment: 'MODERN_EQUIPMENT',
    RentalAvailable: 'RENTAL_AVAILABLE',
    ParkingAvailable: 'PARKING_AVAILABLE',
    EatAvailable: 'EAT_AVAILABLE',
    ShowerAvailable: 'SHOWER_AVAILABLE',
    ChildcareAvailable: 'CHILDCARE_AVAILABLE',
    ClassesAvailable: 'CLASSES_AVAILABLE',
    EventAvailable: 'EVENT_AVAILABLE',
    WheelchairAccessible: 'WHEELCHAIR_ACCESSIBLE',
    SafeEnvironment: 'SAFE_ENVIRONMENT',
    ChangingRoom: 'CHANGING_ROOM',
    PetFriendly: 'PET_FRIENDLY',
    AllHours: 'ALL_HOURS'
} as const;

export type ReviewDTOTagsEnum = typeof ReviewDTOTagsEnum[keyof typeof ReviewDTOTagsEnum];

/**
 * 
 * @export
 * @interface TagDTO
 */
export interface TagDTO {
    /**
     * 
     * @type {string}
     * @memberof TagDTO
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof TagDTO
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profilePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Oauth>}
     * @memberof User
     */
    'oauthList'?: Array<Oauth>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'modifiedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fcmToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googleCalenderId'?: string;
    /**
     * 
     * @type {Array<Notification>}
     * @memberof User
     */
    'notifications'?: Array<Notification>;
    /**
     * 
     * @type {Set<ActivityParticipants>}
     * @memberof User
     */
    'activityParticipants'?: Set<ActivityParticipants>;
    /**
     * 
     * @type {Array<ChatParticipant>}
     * @memberof User
     */
    'chatParticipants'?: Array<ChatParticipant>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'new'?: boolean;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER',
    SuperAdmin: 'SUPER_ADMIN'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface UserChangeInfoDTO
 */
export interface UserChangeInfoDTO {
    /**
     * 변경할 닉네임
     * @type {string}
     * @memberof UserChangeInfoDTO
     */
    'nickname'?: string;
    /**
     * 변경할 소개글
     * @type {string}
     * @memberof UserChangeInfoDTO
     */
    'description'?: string;
}
/**
 * 회원가입 요청 데이터
 * @export
 * @interface UserJoinDTO
 */
export interface UserJoinDTO {
    /**
     * 사용자 이메일
     * @type {string}
     * @memberof UserJoinDTO
     */
    'email': string;
    /**
     * 사용자 비밀번호
     * @type {string}
     * @memberof UserJoinDTO
     */
    'password': string;
    /**
     * 비밀번호 확인
     * @type {string}
     * @memberof UserJoinDTO
     */
    'checkPassword': string;
    /**
     * 사용자 닉네임
     * @type {string}
     * @memberof UserJoinDTO
     */
    'nickname': string;
}
/**
 * 
 * @export
 * @interface UserLoginDTO
 */
export interface UserLoginDTO {
    /**
     * 사용자 이메일
     * @type {string}
     * @memberof UserLoginDTO
     */
    'email': string;
    /**
     * 사용자 비밀번호
     * @type {string}
     * @memberof UserLoginDTO
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginDTO
     */
    'fcmToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserLoginDTO
     */
    'passwordEmpty'?: boolean;
}

/**
 * ActivityControllerApi - axios parameter creator
 * @export
 */
export const ActivityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 새로운 모임을 생성하고, 생성된 모임 정보를 반환합니다.
         * @summary 모임 생성
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (activityRequestDTO: ActivityRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityRequestDTO' is not null or undefined
            assertParamExists('createActivity', 'activityRequestDTO', activityRequestDTO)
            const localVarPath = `/api/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 ID의 모임을 삭제합니다.
         * @summary 모임 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity: async (activityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('deleteActivity', 'activityId', activityId)
            const localVarPath = `/api/activity/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 유저 아이디를 통해 유저의 모임들을 조회합니다
         * @summary 내 모임 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivitiesByUserId: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('findActivitiesByUserId', 'pageable', pageable)
            const localVarPath = `/api/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 ID에 해당하는 모임 정보를 반환합니다.
         * @summary 모임을 ID로 검색
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity: async (activityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('getActivity', 'activityId', activityId)
            const localVarPath = `/api/activity/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모임 정보를 업데이트하고, 수정된 정보를 반환합니다.
         * @summary 모임 수정
         * @param {number} activityId 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity: async (activityId: number, activityRequestDTO: ActivityRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('updateActivity', 'activityId', activityId)
            // verify required parameter 'activityRequestDTO' is not null or undefined
            assertParamExists('updateActivity', 'activityRequestDTO', activityRequestDTO)
            const localVarPath = `/api/activity/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityControllerApi - functional programming interface
 * @export
 */
export const ActivityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 새로운 모임을 생성하고, 생성된 모임 정보를 반환합니다.
         * @summary 모임 생성
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(activityRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityControllerApi.createActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 ID의 모임을 삭제합니다.
         * @summary 모임 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteActivity(activityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(activityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityControllerApi.deleteActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 유저 아이디를 통해 유저의 모임들을 조회합니다
         * @summary 내 모임 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findActivitiesByUserId(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findActivitiesByUserId(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityControllerApi.findActivitiesByUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 ID에 해당하는 모임 정보를 반환합니다.
         * @summary 모임을 ID로 검색
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivity(activityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(activityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityControllerApi.getActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모임 정보를 업데이트하고, 수정된 정보를 반환합니다.
         * @summary 모임 수정
         * @param {number} activityId 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivity(activityId: number, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(activityId, activityRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityControllerApi.updateActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityControllerApi - factory interface
 * @export
 */
export const ActivityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityControllerApiFp(configuration)
    return {
        /**
         * 새로운 모임을 생성하고, 생성된 모임 정보를 반환합니다.
         * @summary 모임 생성
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ActivityResponseDTO> {
            return localVarFp.createActivity(activityRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 ID의 모임을 삭제합니다.
         * @summary 모임 삭제
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteActivity(activityId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.deleteActivity(activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 유저 아이디를 통해 유저의 모임들을 조회합니다
         * @summary 내 모임 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findActivitiesByUserId(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PagedModel> {
            return localVarFp.findActivitiesByUserId(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 ID에 해당하는 모임 정보를 반환합니다.
         * @summary 모임을 ID로 검색
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivity(activityId: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivityResponseDTO> {
            return localVarFp.getActivity(activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 모임 정보를 업데이트하고, 수정된 정보를 반환합니다.
         * @summary 모임 수정
         * @param {number} activityId 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivity(activityId: number, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ActivityResponseDTO> {
            return localVarFp.updateActivity(activityId, activityRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityControllerApi - object-oriented interface
 * @export
 * @class ActivityControllerApi
 * @extends {BaseAPI}
 */
export class ActivityControllerApi extends BaseAPI {
    /**
     * 새로운 모임을 생성하고, 생성된 모임 정보를 반환합니다.
     * @summary 모임 생성
     * @param {ActivityRequestDTO} activityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public createActivity(activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig) {
        return ActivityControllerApiFp(this.configuration).createActivity(activityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 ID의 모임을 삭제합니다.
     * @summary 모임 삭제
     * @param {number} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public deleteActivity(activityId: number, options?: RawAxiosRequestConfig) {
        return ActivityControllerApiFp(this.configuration).deleteActivity(activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 유저 아이디를 통해 유저의 모임들을 조회합니다
     * @summary 내 모임 조회
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public findActivitiesByUserId(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return ActivityControllerApiFp(this.configuration).findActivitiesByUserId(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 ID에 해당하는 모임 정보를 반환합니다.
     * @summary 모임을 ID로 검색
     * @param {number} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public getActivity(activityId: number, options?: RawAxiosRequestConfig) {
        return ActivityControllerApiFp(this.configuration).getActivity(activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모임 정보를 업데이트하고, 수정된 정보를 반환합니다.
     * @summary 모임 수정
     * @param {number} activityId 
     * @param {ActivityRequestDTO} activityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public updateActivity(activityId: number, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig) {
        return ActivityControllerApiFp(this.configuration).updateActivity(activityId, activityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivityMeetingBoardControllerApi - axios parameter creator
 * @export
 */
export const ActivityMeetingBoardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 모임 게시판과 모임을 동시에 생성합니다
         * @summary 모임 생성하기
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingActivity: async (meetingBoardRequestDTO: MeetingBoardRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
            assertParamExists('createMeetingActivity', 'meetingBoardRequestDTO', meetingBoardRequestDTO)
            const localVarPath = `/api/facade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingBoardRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모임 게시판과 모임을 동시에 수정합니다
         * @summary 모임 수정하기
         * @param {number} activityId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingActivity: async (activityId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('updateMeetingActivity', 'activityId', activityId)
            // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
            assertParamExists('updateMeetingActivity', 'meetingBoardRequestDTO', meetingBoardRequestDTO)
            const localVarPath = `/api/facade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingBoardRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityMeetingBoardControllerApi - functional programming interface
 * @export
 */
export const ActivityMeetingBoardControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityMeetingBoardControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 모임 게시판과 모임을 동시에 생성합니다
         * @summary 모임 생성하기
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMeetingActivity(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingBoardResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMeetingActivity(meetingBoardRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityMeetingBoardControllerApi.createMeetingActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모임 게시판과 모임을 동시에 수정합니다
         * @summary 모임 수정하기
         * @param {number} activityId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeetingActivity(activityId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingBoardResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeetingActivity(activityId, meetingBoardRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityMeetingBoardControllerApi.updateMeetingActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityMeetingBoardControllerApi - factory interface
 * @export
 */
export const ActivityMeetingBoardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityMeetingBoardControllerApiFp(configuration)
    return {
        /**
         * 모임 게시판과 모임을 동시에 생성합니다
         * @summary 모임 생성하기
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingActivity(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MeetingBoardResponseDTO> {
            return localVarFp.createMeetingActivity(meetingBoardRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 모임 게시판과 모임을 동시에 수정합니다
         * @summary 모임 수정하기
         * @param {number} activityId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingActivity(activityId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MeetingBoardResponseDTO> {
            return localVarFp.updateMeetingActivity(activityId, meetingBoardRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityMeetingBoardControllerApi - object-oriented interface
 * @export
 * @class ActivityMeetingBoardControllerApi
 * @extends {BaseAPI}
 */
export class ActivityMeetingBoardControllerApi extends BaseAPI {
    /**
     * 모임 게시판과 모임을 동시에 생성합니다
     * @summary 모임 생성하기
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityMeetingBoardControllerApi
     */
    public createMeetingActivity(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig) {
        return ActivityMeetingBoardControllerApiFp(this.configuration).createMeetingActivity(meetingBoardRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모임 게시판과 모임을 동시에 수정합니다
     * @summary 모임 수정하기
     * @param {number} activityId 
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityMeetingBoardControllerApi
     */
    public updateMeetingActivity(activityId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig) {
        return ActivityMeetingBoardControllerApiFp(this.configuration).updateMeetingActivity(activityId, meetingBoardRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ActivityParticipantsControllerApi - axios parameter creator
 * @export
 */
export const ActivityParticipantsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 모임 아이디를 기반으로 모임을 참가합니다
         * @summary 모임 참가
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinActivity: async (activityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('joinActivity', 'activityId', activityId)
            const localVarPath = `/api/activity-participants/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모임 아이디 기반 모임 나가기
         * @summary 모임 나가기
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quitActivity: async (activityId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activityId' is not null or undefined
            assertParamExists('quitActivity', 'activityId', activityId)
            const localVarPath = `/api/activity-participants/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityParticipantsControllerApi - functional programming interface
 * @export
 */
export const ActivityParticipantsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivityParticipantsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 모임 아이디를 기반으로 모임을 참가합니다
         * @summary 모임 참가
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinActivity(activityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinActivity(activityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityParticipantsControllerApi.joinActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모임 아이디 기반 모임 나가기
         * @summary 모임 나가기
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quitActivity(activityId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quitActivity(activityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivityParticipantsControllerApi.quitActivity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivityParticipantsControllerApi - factory interface
 * @export
 */
export const ActivityParticipantsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivityParticipantsControllerApiFp(configuration)
    return {
        /**
         * 모임 아이디를 기반으로 모임을 참가합니다
         * @summary 모임 참가
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinActivity(activityId: number, options?: RawAxiosRequestConfig): AxiosPromise<ActivityResponseDTO> {
            return localVarFp.joinActivity(activityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 모임 아이디 기반 모임 나가기
         * @summary 모임 나가기
         * @param {number} activityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quitActivity(activityId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.quitActivity(activityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivityParticipantsControllerApi - object-oriented interface
 * @export
 * @class ActivityParticipantsControllerApi
 * @extends {BaseAPI}
 */
export class ActivityParticipantsControllerApi extends BaseAPI {
    /**
     * 모임 아이디를 기반으로 모임을 참가합니다
     * @summary 모임 참가
     * @param {number} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityParticipantsControllerApi
     */
    public joinActivity(activityId: number, options?: RawAxiosRequestConfig) {
        return ActivityParticipantsControllerApiFp(this.configuration).joinActivity(activityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모임 아이디 기반 모임 나가기
     * @summary 모임 나가기
     * @param {number} activityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityParticipantsControllerApi
     */
    public quitActivity(activityId: number, options?: RawAxiosRequestConfig) {
        return ActivityParticipantsControllerApiFp(this.configuration).quitActivity(activityId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminControllerApi - axios parameter creator
 * @export
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdmin: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAdmin', 'userId', userId)
            const localVarPath = `/api/admin/super/admin/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAdmins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/super/admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/super/codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCode: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/super/code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AdminJoinDTO} adminJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinAdmin: async (adminJoinDTO: AdminJoinDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminJoinDTO' is not null or undefined
            assertParamExists('joinAdmin', 'adminJoinDTO', adminJoinDTO)
            const localVarPath = `/api/admin/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (adminJoinDTO !== undefined) {
                for (const [key, value] of Object.entries(adminJoinDTO)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdmin(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAdmin(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.deleteAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllAdmins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllAdmins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.findAllAdmins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.findAllCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.findAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateCode(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminCode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateCode(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.generateCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AdminJoinDTO} adminJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinAdmin(adminJoinDTO: AdminJoinDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinAdmin(adminJoinDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminControllerApi.joinAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdmin(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.deleteAdmin(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAdmins(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.findAllAdmins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCode(options?: RawAxiosRequestConfig): AxiosPromise<Array<AdminCode>> {
            return localVarFp.findAllCode(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.findAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateCode(options?: RawAxiosRequestConfig): AxiosPromise<Array<AdminCode>> {
            return localVarFp.generateCode(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AdminJoinDTO} adminJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinAdmin(adminJoinDTO: AdminJoinDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.joinAdmin(adminJoinDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteAdmin(userId: string, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).deleteAdmin(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public findAllAdmins(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).findAllAdmins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public findAllCode(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).findAllCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public findAllUsers(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).findAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public generateCode(options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).generateCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AdminJoinDTO} adminJoinDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public joinAdmin(adminJoinDTO: AdminJoinDTO, options?: RawAxiosRequestConfig) {
        return AdminControllerApiFp(this.configuration).joinAdmin(adminJoinDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalendarControllerApi - axios parameter creator
 * @export
 */
export const CalendarControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendar: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendar/{summary}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalendars: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarControllerApi - functional programming interface
 * @export
 */
export const CalendarControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCalendar(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCalendar(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarControllerApi.createCalendar']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCalendars(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCalendars(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarControllerApi.listCalendars']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalendarControllerApi - factory interface
 * @export
 */
export const CalendarControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCalendar(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createCalendar(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalendars(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listCalendars(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarControllerApi - object-oriented interface
 * @export
 * @class CalendarControllerApi
 * @extends {BaseAPI}
 */
export class CalendarControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarControllerApi
     */
    public createCalendar(options?: RawAxiosRequestConfig) {
        return CalendarControllerApiFp(this.configuration).createCalendar(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarControllerApi
     */
    public listCalendars(options?: RawAxiosRequestConfig) {
        return CalendarControllerApiFp(this.configuration).listCalendars(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatParticipantControllerApi - axios parameter creator
 * @export
 */
export const ChatParticipantControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 특정 채팅방에 속한 참가자의 정보를 조회합니다.
         * @summary 채팅 참가자 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipant: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('getParticipant', 'chatRoomId', chatRoomId)
            const localVarPath = `/api/chat/chatparticipant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chatRoomId !== undefined) {
                localVarQueryParameter['chatRoomId'] = chatRoomId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatParticipantControllerApi - functional programming interface
 * @export
 */
export const ChatParticipantControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatParticipantControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 특정 채팅방에 속한 참가자의 정보를 조회합니다.
         * @summary 채팅 참가자 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParticipant(chatRoomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatParticipantResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParticipant(chatRoomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatParticipantControllerApi.getParticipant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatParticipantControllerApi - factory interface
 * @export
 */
export const ChatParticipantControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatParticipantControllerApiFp(configuration)
    return {
        /**
         * 특정 채팅방에 속한 참가자의 정보를 조회합니다.
         * @summary 채팅 참가자 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParticipant(chatRoomId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChatParticipantResponseDTO> {
            return localVarFp.getParticipant(chatRoomId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatParticipantControllerApi - object-oriented interface
 * @export
 * @class ChatParticipantControllerApi
 * @extends {BaseAPI}
 */
export class ChatParticipantControllerApi extends BaseAPI {
    /**
     * 특정 채팅방에 속한 참가자의 정보를 조회합니다.
     * @summary 채팅 참가자 정보 조회
     * @param {number} chatRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatParticipantControllerApi
     */
    public getParticipant(chatRoomId: number, options?: RawAxiosRequestConfig) {
        return ChatParticipantControllerApiFp(this.configuration).getParticipant(chatRoomId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatRoomControllerApi - axios parameter creator
 * @export
 */
export const ChatRoomControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 새로운 그룹 채팅방을 생성합니다.
         * @summary 그룹 채팅방 생성
         * @param {ChatRoomRequestDTO} chatRoomRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatRoom: async (chatRoomRequestDTO: ChatRoomRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomRequestDTO' is not null or undefined
            assertParamExists('createChatRoom', 'chatRoomRequestDTO', chatRoomRequestDTO)
            const localVarPath = `/api/chatroom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatRoomRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재 존재하는 모든 채팅방을 조회합니다.
         * @summary 모든 채팅방 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChatRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/chatroom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 채팅방의 정보를 조회합니다.
         * @summary 특정 채팅방 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatRoomById: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('getChatRoomById', 'chatRoomId', chatRoomId)
            const localVarPath = `/api/chatroom/{chatRoomId}`
                .replace(`{${"chatRoomId"}}`, encodeURIComponent(String(chatRoomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자가 특정 채팅방에 입장합니다.
         * @summary 특정 채팅방 입장
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinChatRoom: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('joinChatRoom', 'chatRoomId', chatRoomId)
            const localVarPath = `/api/chatroom/{chatRoomId}/join`
                .replace(`{${"chatRoomId"}}`, encodeURIComponent(String(chatRoomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 참가자가 채팅방을 나갑니다.
         * @summary 채팅방 나가기
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveChatRoom: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('leaveChatRoom', 'chatRoomId', chatRoomId)
            const localVarPath = `/api/chatroom/{chatRoomId}/leave`
                .replace(`{${"chatRoomId"}}`, encodeURIComponent(String(chatRoomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatRoomControllerApi - functional programming interface
 * @export
 */
export const ChatRoomControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatRoomControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 새로운 그룹 채팅방을 생성합니다.
         * @summary 그룹 채팅방 생성
         * @param {ChatRoomRequestDTO} chatRoomRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChatRoom(chatRoomRequestDTO: ChatRoomRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChatRoom(chatRoomRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatRoomControllerApi.createChatRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 현재 존재하는 모든 채팅방을 조회합니다.
         * @summary 모든 채팅방 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllChatRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllChatRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatRoomControllerApi.getAllChatRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 채팅방의 정보를 조회합니다.
         * @summary 특정 채팅방 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatRoomById(chatRoomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatRoomResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomById(chatRoomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatRoomControllerApi.getChatRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자가 특정 채팅방에 입장합니다.
         * @summary 특정 채팅방 입장
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinChatRoom(chatRoomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatRoomControllerApi.joinChatRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 참가자가 채팅방을 나갑니다.
         * @summary 채팅방 나가기
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaveChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaveChatRoom(chatRoomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatRoomControllerApi.leaveChatRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatRoomControllerApi - factory interface
 * @export
 */
export const ChatRoomControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatRoomControllerApiFp(configuration)
    return {
        /**
         * 새로운 그룹 채팅방을 생성합니다.
         * @summary 그룹 채팅방 생성
         * @param {ChatRoomRequestDTO} chatRoomRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChatRoom(chatRoomRequestDTO: ChatRoomRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<ChatRoomResponseDTO> {
            return localVarFp.createChatRoom(chatRoomRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재 존재하는 모든 채팅방을 조회합니다.
         * @summary 모든 채팅방 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChatRooms(options?: RawAxiosRequestConfig): AxiosPromise<ChatRoomResponseDTO> {
            return localVarFp.getAllChatRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 채팅방의 정보를 조회합니다.
         * @summary 특정 채팅방 정보 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatRoomById(chatRoomId: number, options?: RawAxiosRequestConfig): AxiosPromise<ChatRoomResponseDTO> {
            return localVarFp.getChatRoomById(chatRoomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자가 특정 채팅방에 입장합니다.
         * @summary 특정 채팅방 입장
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.joinChatRoom(chatRoomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 참가자가 채팅방을 나갑니다.
         * @summary 채팅방 나가기
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leaveChatRoom(chatRoomId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatRoomControllerApi - object-oriented interface
 * @export
 * @class ChatRoomControllerApi
 * @extends {BaseAPI}
 */
export class ChatRoomControllerApi extends BaseAPI {
    /**
     * 새로운 그룹 채팅방을 생성합니다.
     * @summary 그룹 채팅방 생성
     * @param {ChatRoomRequestDTO} chatRoomRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatRoomControllerApi
     */
    public createChatRoom(chatRoomRequestDTO: ChatRoomRequestDTO, options?: RawAxiosRequestConfig) {
        return ChatRoomControllerApiFp(this.configuration).createChatRoom(chatRoomRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재 존재하는 모든 채팅방을 조회합니다.
     * @summary 모든 채팅방 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatRoomControllerApi
     */
    public getAllChatRooms(options?: RawAxiosRequestConfig) {
        return ChatRoomControllerApiFp(this.configuration).getAllChatRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 채팅방의 정보를 조회합니다.
     * @summary 특정 채팅방 정보 조회
     * @param {number} chatRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatRoomControllerApi
     */
    public getChatRoomById(chatRoomId: number, options?: RawAxiosRequestConfig) {
        return ChatRoomControllerApiFp(this.configuration).getChatRoomById(chatRoomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자가 특정 채팅방에 입장합니다.
     * @summary 특정 채팅방 입장
     * @param {number} chatRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatRoomControllerApi
     */
    public joinChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig) {
        return ChatRoomControllerApiFp(this.configuration).joinChatRoom(chatRoomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 참가자가 채팅방을 나갑니다.
     * @summary 채팅방 나가기
     * @param {number} chatRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatRoomControllerApi
     */
    public leaveChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig) {
        return ChatRoomControllerApiFp(this.configuration).leaveChatRoom(chatRoomId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ControllerApi - axios parameter creator
 * @export
 */
export const ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControllerApi - functional programming interface
 * @export
 */
export const ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async home(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.home(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControllerApi.home']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControllerApi - factory interface
 * @export
 */
export const ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.home(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControllerApi - object-oriented interface
 * @export
 * @class ControllerApi
 * @extends {BaseAPI}
 */
export class ControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public home(options?: RawAxiosRequestConfig) {
        return ControllerApiFp(this.configuration).home(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailControllerApi - axios parameter creator
 * @export
 */
export const EmailControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 이메일 인증을 위한 코드를 발송합니다
         * @summary 이메일 발송
         * @param {string} email 인증번호를 보낼 email 주소
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCode: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('sendCode', 'email', email)
            const localVarPath = `/api/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
         * @summary 검증
         * @param {string} email 인증번호를 보낸 email 주소
         * @param {string} code 받은 인증번호
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode: async (email: string, code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('verifyCode', 'email', email)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('verifyCode', 'code', code)
            const localVarPath = `/api/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export const EmailControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 이메일 인증을 위한 코드를 발송합니다
         * @summary 이메일 발송
         * @param {string} email 인증번호를 보낼 email 주소
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendCode(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendCode(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailControllerApi.sendCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
         * @summary 검증
         * @param {string} email 인증번호를 보낸 email 주소
         * @param {string} code 받은 인증번호
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyCode(email: string, code: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCode(email, code, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailControllerApi.verifyCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailControllerApi - factory interface
 * @export
 */
export const EmailControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailControllerApiFp(configuration)
    return {
        /**
         * 이메일 인증을 위한 코드를 발송합니다
         * @summary 이메일 발송
         * @param {string} email 인증번호를 보낼 email 주소
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendCode(email: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendCode(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
         * @summary 검증
         * @param {string} email 인증번호를 보낸 email 주소
         * @param {string} code 받은 인증번호
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(email: string, code: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifyCode(email, code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export class EmailControllerApi extends BaseAPI {
    /**
     * 이메일 인증을 위한 코드를 발송합니다
     * @summary 이메일 발송
     * @param {string} email 인증번호를 보낼 email 주소
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public sendCode(email: string, options?: RawAxiosRequestConfig) {
        return EmailControllerApiFp(this.configuration).sendCode(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
     * @summary 검증
     * @param {string} email 인증번호를 보낸 email 주소
     * @param {string} code 받은 인증번호
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public verifyCode(email: string, code: string, options?: RawAxiosRequestConfig) {
        return EmailControllerApiFp(this.configuration).verifyCode(email, code, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventControllerApi - axios parameter creator
 * @export
 */
export const EventControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (email: string, activityRequestDTO: ActivityRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('createEvent', 'email', email)
            // verify required parameter 'activityRequestDTO' is not null or undefined
            assertParamExists('createEvent', 'activityRequestDTO', activityRequestDTO)
            const localVarPath = `/api/google-calendar/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} googleCalenderId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent: async (googleCalenderId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleCalenderId' is not null or undefined
            assertParamExists('deleteEvent', 'googleCalenderId', googleCalenderId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteEvent', 'body', body)
            const localVarPath = `/api/google-calendar/event/eventId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (googleCalenderId !== undefined) {
                localVarQueryParameter['googleCalenderId'] = googleCalenderId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/google-calendar/event/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (email: string, activityRequestDTO: ActivityRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('updateEvent', 'email', email)
            // verify required parameter 'activityRequestDTO' is not null or undefined
            assertParamExists('updateEvent', 'activityRequestDTO', activityRequestDTO)
            const localVarPath = `/api/google-calendar/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(activityRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventControllerApi - functional programming interface
 * @export
 */
export const EventControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(email, activityRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventControllerApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} googleCalenderId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvent(googleCalenderId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(googleCalenderId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventControllerApi.deleteEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventControllerApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(email, activityRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventControllerApi.updateEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventControllerApi - factory interface
 * @export
 */
export const EventControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createEvent(email, activityRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} googleCalenderId 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(googleCalenderId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteEvent(googleCalenderId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(options?: RawAxiosRequestConfig): AxiosPromise<Events> {
            return localVarFp.listEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} email 
         * @param {ActivityRequestDTO} activityRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateEvent(email, activityRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventControllerApi - object-oriented interface
 * @export
 * @class EventControllerApi
 * @extends {BaseAPI}
 */
export class EventControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} email 
     * @param {ActivityRequestDTO} activityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public createEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig) {
        return EventControllerApiFp(this.configuration).createEvent(email, activityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} googleCalenderId 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public deleteEvent(googleCalenderId: string, body: string, options?: RawAxiosRequestConfig) {
        return EventControllerApiFp(this.configuration).deleteEvent(googleCalenderId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public listEvents(options?: RawAxiosRequestConfig) {
        return EventControllerApiFp(this.configuration).listEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} email 
     * @param {ActivityRequestDTO} activityRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventControllerApi
     */
    public updateEvent(email: string, activityRequestDTO: ActivityRequestDTO, options?: RawAxiosRequestConfig) {
        return EventControllerApiFp(this.configuration).updateEvent(email, activityRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FacilityControllerApi - axios parameter creator
 * @export
 */
export const FacilityControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
         * @summary 모든 시설 상세 정보 저장
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllFacilityDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/facility-detail/all-memory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/facility-detail/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 시설 상세 정보를 삭제합니다.
         * @summary 시설 상세 정보 삭제
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFacilityDetail: async (facilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('deleteFacilityDetail', 'facilityId', facilityId)
            const localVarPath = `/api/facility-detail/{facilityId}`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
         * @summary 시설 필터링 검색
         * @param {Pageable} pageable 
         * @param {FacilityFilterDTO} facilityFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        facilityFilter: async (pageable: Pageable, facilityFilterDTO: FacilityFilterDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('facilityFilter', 'pageable', pageable)
            // verify required parameter 'facilityFilterDTO' is not null or undefined
            assertParamExists('facilityFilter', 'facilityFilterDTO', facilityFilterDTO)
            const localVarPath = `/api/facility-detail/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(facilityFilterDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 시설 목록을 페이지 단위로 조회합니다.
         * @summary 시설 목록 페이지 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacilities: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllFacilities', 'pageable', pageable)
            const localVarPath = `/api/facility-detail/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
         * @summary 시설 상세 정보 목록 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacilityDetails: async (pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAllFacilityDetails', 'pageable', pageable)
            const localVarPath = `/api/facility-detail/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 시설의 이름으로 상세 정보를 가져옵니다.
         * @summary 시설 상세 정보 가져오기
         * @param {string} facilityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFacilityDetail: async (facilityName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityName' is not null or undefined
            assertParamExists('getFacilityDetail', 'facilityName', facilityName)
            const localVarPath = `/api/facility-detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (facilityName !== undefined) {
                localVarQueryParameter['facilityName'] = facilityName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 시설 ID로 상세 정보를 조회합니다.
         * @summary 시설 상세 정보 페이지 조회
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFacilityDetails: async (facilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('readFacilityDetails', 'facilityId', facilityId)
            const localVarPath = `/api/facility-detail/{facilityId}`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
         * @summary 위치기반 시설 검색
         * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByLocation: async (facilityLocationDTO: FacilityLocationDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityLocationDTO' is not null or undefined
            assertParamExists('searchByLocation', 'facilityLocationDTO', facilityLocationDTO)
            const localVarPath = `/api/facility-detail/location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(facilityLocationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 시설 상세 정보를 업데이트합니다.
         * @summary 시설 상세 정보 업데이트
         * @param {string} facilityId 
         * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFacilityDetail: async (facilityId: string, facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('updateFacilityDetail', 'facilityId', facilityId)
            // verify required parameter 'facilityDetailsUpdateDTO' is not null or undefined
            assertParamExists('updateFacilityDetail', 'facilityDetailsUpdateDTO', facilityDetailsUpdateDTO)
            const localVarPath = `/api/facility-detail/{facilityId}`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(facilityDetailsUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FacilityControllerApi - functional programming interface
 * @export
 */
export const FacilityControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FacilityControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
         * @summary 모든 시설 상세 정보 저장
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAllFacilityDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAllFacilityDetails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.addAllFacilityDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.deleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 시설 상세 정보를 삭제합니다.
         * @summary 시설 상세 정보 삭제
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFacilityDetail(facilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFacilityDetail(facilityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.deleteFacilityDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
         * @summary 시설 필터링 검색
         * @param {Pageable} pageable 
         * @param {FacilityFilterDTO} facilityFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async facilityFilter(pageable: Pageable, facilityFilterDTO: FacilityFilterDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.facilityFilter(pageable, facilityFilterDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.facilityFilter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 시설 목록을 페이지 단위로 조회합니다.
         * @summary 시설 목록 페이지 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFacilities(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFacilities(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.getAllFacilities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
         * @summary 시설 상세 정보 목록 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFacilityDetails(pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFacilityDetails(pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.getAllFacilityDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 시설의 이름으로 상세 정보를 가져옵니다.
         * @summary 시설 상세 정보 가져오기
         * @param {string} facilityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFacilityDetail(facilityName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFacilityDetail(facilityName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.getFacilityDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 시설 ID로 상세 정보를 조회합니다.
         * @summary 시설 상세 정보 페이지 조회
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readFacilityDetails(facilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FacilityDetailsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readFacilityDetails(facilityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.readFacilityDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
         * @summary 위치기반 시설 검색
         * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByLocation(facilityLocationDTO: FacilityLocationDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByLocation(facilityLocationDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.searchByLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 시설 상세 정보를 업데이트합니다.
         * @summary 시설 상세 정보 업데이트
         * @param {string} facilityId 
         * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFacilityDetail(facilityId: string, facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FacilityDetailsResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFacilityDetail(facilityId, facilityDetailsUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityControllerApi.updateFacilityDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FacilityControllerApi - factory interface
 * @export
 */
export const FacilityControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FacilityControllerApiFp(configuration)
    return {
        /**
         * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
         * @summary 모든 시설 상세 정보 저장
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAllFacilityDetails(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addAllFacilityDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAll(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.deleteAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 시설 상세 정보를 삭제합니다.
         * @summary 시설 상세 정보 삭제
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFacilityDetail(facilityId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.deleteFacilityDetail(facilityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
         * @summary 시설 필터링 검색
         * @param {Pageable} pageable 
         * @param {FacilityFilterDTO} facilityFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        facilityFilter(pageable: Pageable, facilityFilterDTO: FacilityFilterDTO, options?: RawAxiosRequestConfig): AxiosPromise<PagedModel> {
            return localVarFp.facilityFilter(pageable, facilityFilterDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 시설 목록을 페이지 단위로 조회합니다.
         * @summary 시설 목록 페이지 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacilities(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllFacilities(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
         * @summary 시설 상세 정보 목록 조회
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacilityDetails(pageable: Pageable, options?: RawAxiosRequestConfig): AxiosPromise<PagedModel> {
            return localVarFp.getAllFacilityDetails(pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * 시설의 이름으로 상세 정보를 가져옵니다.
         * @summary 시설 상세 정보 가져오기
         * @param {string} facilityName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFacilityDetail(facilityName: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getFacilityDetail(facilityName, options).then((request) => request(axios, basePath));
        },
        /**
         * 시설 ID로 상세 정보를 조회합니다.
         * @summary 시설 상세 정보 페이지 조회
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFacilityDetails(facilityId: string, options?: RawAxiosRequestConfig): AxiosPromise<FacilityDetailsResponseDTO> {
            return localVarFp.readFacilityDetails(facilityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
         * @summary 위치기반 시설 검색
         * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByLocation(facilityLocationDTO: FacilityLocationDTO, options?: RawAxiosRequestConfig): AxiosPromise<PagedModel> {
            return localVarFp.searchByLocation(facilityLocationDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 시설 상세 정보를 업데이트합니다.
         * @summary 시설 상세 정보 업데이트
         * @param {string} facilityId 
         * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFacilityDetail(facilityId: string, facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<FacilityDetailsResponseDTO> {
            return localVarFp.updateFacilityDetail(facilityId, facilityDetailsUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FacilityControllerApi - object-oriented interface
 * @export
 * @class FacilityControllerApi
 * @extends {BaseAPI}
 */
export class FacilityControllerApi extends BaseAPI {
    /**
     * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
     * @summary 모든 시설 상세 정보 저장
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public addAllFacilityDetails(options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).addAllFacilityDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public deleteAll(options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).deleteAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 시설 상세 정보를 삭제합니다.
     * @summary 시설 상세 정보 삭제
     * @param {string} facilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public deleteFacilityDetail(facilityId: string, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).deleteFacilityDetail(facilityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
     * @summary 시설 필터링 검색
     * @param {Pageable} pageable 
     * @param {FacilityFilterDTO} facilityFilterDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public facilityFilter(pageable: Pageable, facilityFilterDTO: FacilityFilterDTO, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).facilityFilter(pageable, facilityFilterDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 시설 목록을 페이지 단위로 조회합니다.
     * @summary 시설 목록 페이지 조회
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public getAllFacilities(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).getAllFacilities(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
     * @summary 시설 상세 정보 목록 조회
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public getAllFacilityDetails(pageable: Pageable, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).getAllFacilityDetails(pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 시설의 이름으로 상세 정보를 가져옵니다.
     * @summary 시설 상세 정보 가져오기
     * @param {string} facilityName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public getFacilityDetail(facilityName: string, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).getFacilityDetail(facilityName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 시설 ID로 상세 정보를 조회합니다.
     * @summary 시설 상세 정보 페이지 조회
     * @param {string} facilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public readFacilityDetails(facilityId: string, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).readFacilityDetails(facilityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
     * @summary 위치기반 시설 검색
     * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public searchByLocation(facilityLocationDTO: FacilityLocationDTO, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).searchByLocation(facilityLocationDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 시설 상세 정보를 업데이트합니다.
     * @summary 시설 상세 정보 업데이트
     * @param {string} facilityId 
     * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityControllerApi
     */
    public updateFacilityDetail(facilityId: string, facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO, options?: RawAxiosRequestConfig) {
        return FacilityControllerApiFp(this.configuration).updateFacilityDetail(facilityId, facilityDetailsUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FacilityLikeControllerApi - axios parameter creator
 * @export
 */
export const FacilityLikeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 시설 아이디를 받아 좋아요를 누릅니다
         * @summary 좋아요
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addlike: async (facilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('addlike', 'facilityId', facilityId)
            const localVarPath = `/api/like-facility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (facilityId !== undefined) {
                localVarQueryParameter['facilityId'] = facilityId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 좋아요를 누른 상태라면 좋아요 취소버튼 활성화 또는 버튼을 다시 누르면 좋아요 취소
         * @summary 좋아요 취소
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislike: async (facilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('dislike', 'facilityId', facilityId)
            const localVarPath = `/api/like-facility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (facilityId !== undefined) {
                localVarQueryParameter['facilityId'] = facilityId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FacilityLikeControllerApi - functional programming interface
 * @export
 */
export const FacilityLikeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FacilityLikeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 시설 아이디를 받아 좋아요를 누릅니다
         * @summary 좋아요
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addlike(facilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addlike(facilityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityLikeControllerApi.addlike']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 좋아요를 누른 상태라면 좋아요 취소버튼 활성화 또는 버튼을 다시 누르면 좋아요 취소
         * @summary 좋아요 취소
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dislike(facilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dislike(facilityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacilityLikeControllerApi.dislike']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FacilityLikeControllerApi - factory interface
 * @export
 */
export const FacilityLikeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FacilityLikeControllerApiFp(configuration)
    return {
        /**
         * 시설 아이디를 받아 좋아요를 누릅니다
         * @summary 좋아요
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addlike(facilityId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.addlike(facilityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 좋아요를 누른 상태라면 좋아요 취소버튼 활성화 또는 버튼을 다시 누르면 좋아요 취소
         * @summary 좋아요 취소
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislike(facilityId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.dislike(facilityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FacilityLikeControllerApi - object-oriented interface
 * @export
 * @class FacilityLikeControllerApi
 * @extends {BaseAPI}
 */
export class FacilityLikeControllerApi extends BaseAPI {
    /**
     * 시설 아이디를 받아 좋아요를 누릅니다
     * @summary 좋아요
     * @param {string} facilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityLikeControllerApi
     */
    public addlike(facilityId: string, options?: RawAxiosRequestConfig) {
        return FacilityLikeControllerApiFp(this.configuration).addlike(facilityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 좋아요를 누른 상태라면 좋아요 취소버튼 활성화 또는 버튼을 다시 누르면 좋아요 취소
     * @summary 좋아요 취소
     * @param {string} facilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacilityLikeControllerApi
     */
    public dislike(facilityId: string, options?: RawAxiosRequestConfig) {
        return FacilityLikeControllerApiFp(this.configuration).dislike(facilityId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FcmControllerApi - axios parameter creator
 * @export
 */
export const FcmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFcmToken: async (userLoginDTO: UserLoginDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginDTO' is not null or undefined
            assertParamExists('handleFcmToken', 'userLoginDTO', userLoginDTO)
            const localVarPath = `/api/fcm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FcmControllerApi - functional programming interface
 * @export
 */
export const FcmControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FcmControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleFcmToken(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleFcmToken(userLoginDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FcmControllerApi.handleFcmToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FcmControllerApi - factory interface
 * @export
 */
export const FcmControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FcmControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFcmToken(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.handleFcmToken(userLoginDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FcmControllerApi - object-oriented interface
 * @export
 * @class FcmControllerApi
 * @extends {BaseAPI}
 */
export class FcmControllerApi extends BaseAPI {
    /**
     * 
     * @param {UserLoginDTO} userLoginDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FcmControllerApi
     */
    public handleFcmToken(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig) {
        return FcmControllerApiFp(this.configuration).handleFcmToken(userLoginDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeetingBoardApi - axios parameter creator
 * @export
 */
export const MeetingBoardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 새로운 모임을 생성합니다.
         * @summary 모임 생성
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingBoard: async (meetingBoardRequestDTO: MeetingBoardRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
            assertParamExists('createMeetingBoard', 'meetingBoardRequestDTO', meetingBoardRequestDTO)
            const localVarPath = `/api/meetingboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingBoardRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 ID의 모임 정보를 삭제합니다.
         * @summary 모임 삭제
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeetingBoard: async (mbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mbId' is not null or undefined
            assertParamExists('deleteMeetingBoard', 'mbId', mbId)
            const localVarPath = `/api/meetingboard/{mbId}`
                .replace(`{${"mbId"}}`, encodeURIComponent(String(mbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 필터를 통해 모임게시판을 검색합니다
         * @summary 모임 검색
         * @param {Pageable} pageable 
         * @param {BoardFilterDTO} boardFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterSearch: async (pageable: Pageable, boardFilterDTO: BoardFilterDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('filterSearch', 'pageable', pageable)
            // verify required parameter 'boardFilterDTO' is not null or undefined
            assertParamExists('filterSearch', 'boardFilterDTO', boardFilterDTO)
            const localVarPath = `/api/meetingboard/filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boardFilterDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 등록된 모든 모임을 조회합니다.
         * @summary 모임 전체 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMeetingBoards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meetingboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 ID의 모임을 조회합니다.
         * @summary 모임 상세 조회
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeetingBoardById: async (mbId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mbId' is not null or undefined
            assertParamExists('getMeetingBoardById', 'mbId', mbId)
            const localVarPath = `/api/meetingboard/{mbId}`
                .replace(`{${"mbId"}}`, encodeURIComponent(String(mbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 ID의 모임 정보를 수정합니다.
         * @summary 모임 수정
         * @param {number} mbId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingBoard: async (mbId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mbId' is not null or undefined
            assertParamExists('updateMeetingBoard', 'mbId', mbId)
            // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
            assertParamExists('updateMeetingBoard', 'meetingBoardRequestDTO', meetingBoardRequestDTO)
            const localVarPath = `/api/meetingboard/{mbId}`
                .replace(`{${"mbId"}}`, encodeURIComponent(String(mbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingBoardRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeetingBoardApi - functional programming interface
 * @export
 */
export const MeetingBoardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeetingBoardApiAxiosParamCreator(configuration)
    return {
        /**
         * 새로운 모임을 생성합니다.
         * @summary 모임 생성
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMeetingBoard(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingBoardResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMeetingBoard(meetingBoardRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.createMeetingBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 ID의 모임 정보를 삭제합니다.
         * @summary 모임 삭제
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeetingBoard(mbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeetingBoard(mbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.deleteMeetingBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 필터를 통해 모임게시판을 검색합니다
         * @summary 모임 검색
         * @param {Pageable} pageable 
         * @param {BoardFilterDTO} boardFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filterSearch(pageable: Pageable, boardFilterDTO: BoardFilterDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filterSearch(pageable, boardFilterDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.filterSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 등록된 모든 모임을 조회합니다.
         * @summary 모임 전체 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMeetingBoards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MeetingBoardResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMeetingBoards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.getAllMeetingBoards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 ID의 모임을 조회합니다.
         * @summary 모임 상세 조회
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeetingBoardById(mbId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingBoardResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeetingBoardById(mbId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.getMeetingBoardById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 ID의 모임 정보를 수정합니다.
         * @summary 모임 수정
         * @param {number} mbId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeetingBoard(mbId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingBoardResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeetingBoard(mbId, meetingBoardRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingBoardApi.updateMeetingBoard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeetingBoardApi - factory interface
 * @export
 */
export const MeetingBoardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeetingBoardApiFp(configuration)
    return {
        /**
         * 새로운 모임을 생성합니다.
         * @summary 모임 생성
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingBoard(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MeetingBoardResponseDTO> {
            return localVarFp.createMeetingBoard(meetingBoardRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 ID의 모임 정보를 삭제합니다.
         * @summary 모임 삭제
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeetingBoard(mbId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMeetingBoard(mbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 필터를 통해 모임게시판을 검색합니다
         * @summary 모임 검색
         * @param {Pageable} pageable 
         * @param {BoardFilterDTO} boardFilterDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filterSearch(pageable: Pageable, boardFilterDTO: BoardFilterDTO, options?: RawAxiosRequestConfig): AxiosPromise<PagedModel> {
            return localVarFp.filterSearch(pageable, boardFilterDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 등록된 모든 모임을 조회합니다.
         * @summary 모임 전체 조회
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMeetingBoards(options?: RawAxiosRequestConfig): AxiosPromise<Array<MeetingBoardResponseDTO>> {
            return localVarFp.getAllMeetingBoards(options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 ID의 모임을 조회합니다.
         * @summary 모임 상세 조회
         * @param {number} mbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeetingBoardById(mbId: number, options?: RawAxiosRequestConfig): AxiosPromise<MeetingBoardResponseDTO> {
            return localVarFp.getMeetingBoardById(mbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 ID의 모임 정보를 수정합니다.
         * @summary 모임 수정
         * @param {number} mbId 
         * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingBoard(mbId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MeetingBoardResponseDTO> {
            return localVarFp.updateMeetingBoard(mbId, meetingBoardRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeetingBoardApi - object-oriented interface
 * @export
 * @class MeetingBoardApi
 * @extends {BaseAPI}
 */
export class MeetingBoardApi extends BaseAPI {
    /**
     * 새로운 모임을 생성합니다.
     * @summary 모임 생성
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public createMeetingBoard(meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).createMeetingBoard(meetingBoardRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 ID의 모임 정보를 삭제합니다.
     * @summary 모임 삭제
     * @param {number} mbId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public deleteMeetingBoard(mbId: number, options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).deleteMeetingBoard(mbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 필터를 통해 모임게시판을 검색합니다
     * @summary 모임 검색
     * @param {Pageable} pageable 
     * @param {BoardFilterDTO} boardFilterDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public filterSearch(pageable: Pageable, boardFilterDTO: BoardFilterDTO, options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).filterSearch(pageable, boardFilterDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 등록된 모든 모임을 조회합니다.
     * @summary 모임 전체 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public getAllMeetingBoards(options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).getAllMeetingBoards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 ID의 모임을 조회합니다.
     * @summary 모임 상세 조회
     * @param {number} mbId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public getMeetingBoardById(mbId: number, options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).getMeetingBoardById(mbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 ID의 모임 정보를 수정합니다.
     * @summary 모임 수정
     * @param {number} mbId 
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeetingBoardApi
     */
    public updateMeetingBoard(mbId: number, meetingBoardRequestDTO: MeetingBoardRequestDTO, options?: RawAxiosRequestConfig) {
        return MeetingBoardApiFp(this.configuration).updateMeetingBoard(mbId, meetingBoardRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessageControllerApi - axios parameter creator
 * @export
 */
export const MessageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 특정 메시지를 삭제합니다.
         * @summary 메시지 삭제
         * @param {number} chatRoomId 
         * @param {number} messageId 
         * @param {string} requesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (chatRoomId: number, messageId: number, requesterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('deleteMessage', 'chatRoomId', chatRoomId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            // verify required parameter 'requesterId' is not null or undefined
            assertParamExists('deleteMessage', 'requesterId', requesterId)
            const localVarPath = `/api/messages/{chatRoomId}/{messageId}`
                .replace(`{${"chatRoomId"}}`, encodeURIComponent(String(chatRoomId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requesterId !== undefined) {
                localVarQueryParameter['requesterId'] = requesterId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 채팅방에 포함된 메시지를 조회합니다.
         * @summary 특정 채팅방 메시지 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByChatRoom: async (chatRoomId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRoomId' is not null or undefined
            assertParamExists('getMessagesByChatRoom', 'chatRoomId', chatRoomId)
            const localVarPath = `/api/messages/{chatRoomId}`
                .replace(`{${"chatRoomId"}}`, encodeURIComponent(String(chatRoomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 특정 채팅방에 메시지를 전송합니다.
         * @summary 메시지 전송
         * @param {MessageRequestDTO} messageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (messageRequestDTO: MessageRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageRequestDTO' is not null or undefined
            assertParamExists('sendMessage', 'messageRequestDTO', messageRequestDTO)
            const localVarPath = `/api/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageControllerApi - functional programming interface
 * @export
 */
export const MessageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 특정 메시지를 삭제합니다.
         * @summary 메시지 삭제
         * @param {number} chatRoomId 
         * @param {number} messageId 
         * @param {string} requesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(chatRoomId: number, messageId: number, requesterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(chatRoomId, messageId, requesterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageControllerApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 채팅방에 포함된 메시지를 조회합니다.
         * @summary 특정 채팅방 메시지 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessagesByChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponseDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesByChatRoom(chatRoomId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageControllerApi.getMessagesByChatRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 특정 채팅방에 메시지를 전송합니다.
         * @summary 메시지 전송
         * @param {MessageRequestDTO} messageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(messageRequestDTO: MessageRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(messageRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessageControllerApi.sendMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessageControllerApi - factory interface
 * @export
 */
export const MessageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageControllerApiFp(configuration)
    return {
        /**
         * 특정 메시지를 삭제합니다.
         * @summary 메시지 삭제
         * @param {number} chatRoomId 
         * @param {number} messageId 
         * @param {string} requesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(chatRoomId: number, messageId: number, requesterId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteMessage(chatRoomId, messageId, requesterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 채팅방에 포함된 메시지를 조회합니다.
         * @summary 특정 채팅방 메시지 조회
         * @param {number} chatRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesByChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponseDTO>> {
            return localVarFp.getMessagesByChatRoom(chatRoomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 특정 채팅방에 메시지를 전송합니다.
         * @summary 메시지 전송
         * @param {MessageRequestDTO} messageRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(messageRequestDTO: MessageRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponseDTO> {
            return localVarFp.sendMessage(messageRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageControllerApi - object-oriented interface
 * @export
 * @class MessageControllerApi
 * @extends {BaseAPI}
 */
export class MessageControllerApi extends BaseAPI {
    /**
     * 특정 메시지를 삭제합니다.
     * @summary 메시지 삭제
     * @param {number} chatRoomId 
     * @param {number} messageId 
     * @param {string} requesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public deleteMessage(chatRoomId: number, messageId: number, requesterId: string, options?: RawAxiosRequestConfig) {
        return MessageControllerApiFp(this.configuration).deleteMessage(chatRoomId, messageId, requesterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 채팅방에 포함된 메시지를 조회합니다.
     * @summary 특정 채팅방 메시지 조회
     * @param {number} chatRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public getMessagesByChatRoom(chatRoomId: number, options?: RawAxiosRequestConfig) {
        return MessageControllerApiFp(this.configuration).getMessagesByChatRoom(chatRoomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 특정 채팅방에 메시지를 전송합니다.
     * @summary 메시지 전송
     * @param {MessageRequestDTO} messageRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public sendMessage(messageRequestDTO: MessageRequestDTO, options?: RawAxiosRequestConfig) {
        return MessageControllerApiFp(this.configuration).sendMessage(messageRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationControllerApi - axios parameter creator
 * @export
 */
export const NotificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NotificationDTO} notificationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification1: async (notificationDTO: NotificationDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationDTO' is not null or undefined
            assertParamExists('sendPushNotification1', 'notificationDTO', notificationDTO)
            const localVarPath = `/api/notification/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationControllerApi - functional programming interface
 * @export
 */
export const NotificationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NotificationDTO} notificationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPushNotification1(notificationDTO: NotificationDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPushNotification1(notificationDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationControllerApi.sendPushNotification1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationControllerApi - factory interface
 * @export
 */
export const NotificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {NotificationDTO} notificationDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification1(notificationDTO: NotificationDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendPushNotification1(notificationDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationControllerApi - object-oriented interface
 * @export
 * @class NotificationControllerApi
 * @extends {BaseAPI}
 */
export class NotificationControllerApi extends BaseAPI {
    /**
     * 
     * @param {NotificationDTO} notificationDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationControllerApi
     */
    public sendPushNotification1(notificationDTO: NotificationDTO, options?: RawAxiosRequestConfig) {
        return NotificationControllerApiFp(this.configuration).sendPushNotification1(notificationDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2ControllerApi - axios parameter creator
 * @export
 */
export const OAuth2ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAUTH2.0을 통해 로그인합니다
         * @summary 소셜 로그인
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogin: async (provider: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthLogin', 'provider', provider)
            const localVarPath = `/api/oauth2/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2ControllerApi - functional programming interface
 * @export
 */
export const OAuth2ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * OAUTH2.0을 통해 로그인합니다
         * @summary 소셜 로그인
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthLogin(provider: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLogin(provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2ControllerApi.oauthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuth2ControllerApi - factory interface
 * @export
 */
export const OAuth2ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2ControllerApiFp(configuration)
    return {
        /**
         * OAUTH2.0을 통해 로그인합니다
         * @summary 소셜 로그인
         * @param {string} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthLogin(provider: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.oauthLogin(provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2ControllerApi - object-oriented interface
 * @export
 * @class OAuth2ControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ControllerApi extends BaseAPI {
    /**
     * OAUTH2.0을 통해 로그인합니다
     * @summary 소셜 로그인
     * @param {string} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2ControllerApi
     */
    public oauthLogin(provider: string, options?: RawAxiosRequestConfig) {
        return OAuth2ControllerApiFp(this.configuration).oauthLogin(provider, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PushNotificationControllerApi - axios parameter creator
 * @export
 */
export const PushNotificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NotificationCreateDTO} notificationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification: async (notificationCreateDTO: NotificationCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notificationCreateDTO' is not null or undefined
            assertParamExists('sendPushNotification', 'notificationCreateDTO', notificationCreateDTO)
            const localVarPath = `/api/push/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/push/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationControllerApi - functional programming interface
 * @export
 */
export const PushNotificationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushNotificationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NotificationCreateDTO} notificationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPushNotification(notificationCreateDTO: NotificationCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPushNotification(notificationCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationControllerApi.sendPushNotification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPushNotification2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPushNotification2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushNotificationControllerApi.sendPushNotification2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PushNotificationControllerApi - factory interface
 * @export
 */
export const PushNotificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushNotificationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {NotificationCreateDTO} notificationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification(notificationCreateDTO: NotificationCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sendPushNotification(notificationCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPushNotification2(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sendPushNotification2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushNotificationControllerApi - object-oriented interface
 * @export
 * @class PushNotificationControllerApi
 * @extends {BaseAPI}
 */
export class PushNotificationControllerApi extends BaseAPI {
    /**
     * 
     * @param {NotificationCreateDTO} notificationCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationControllerApi
     */
    public sendPushNotification(notificationCreateDTO: NotificationCreateDTO, options?: RawAxiosRequestConfig) {
        return PushNotificationControllerApiFp(this.configuration).sendPushNotification(notificationCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationControllerApi
     */
    public sendPushNotification2(options?: RawAxiosRequestConfig) {
        return PushNotificationControllerApiFp(this.configuration).sendPushNotification2(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReviewControllerApi - axios parameter creator
 * @export
 */
export const ReviewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} facilityId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview: async (facilityId: string, reviewDTO: ReviewDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('createReview', 'facilityId', facilityId)
            // verify required parameter 'reviewDTO' is not null or undefined
            assertParamExists('createReview', 'reviewDTO', reviewDTO)
            const localVarPath = `/api/facility-detail/{facilityId}/reviews`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview: async (facilityId: string, reviewId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('deleteReview', 'facilityId', facilityId)
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('deleteReview', 'reviewId', reviewId)
            const localVarPath = `/api/facility-detail/{facilityId}/reviews/{reviewId}`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)))
                .replace(`{${"reviewId"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByFacility: async (facilityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('getReviewsByFacility', 'facilityId', facilityId)
            const localVarPath = `/api/facility-detail/{facilityId}/reviews`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview: async (facilityId: string, reviewId: number, reviewDTO: ReviewDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'facilityId' is not null or undefined
            assertParamExists('updateReview', 'facilityId', facilityId)
            // verify required parameter 'reviewId' is not null or undefined
            assertParamExists('updateReview', 'reviewId', reviewId)
            // verify required parameter 'reviewDTO' is not null or undefined
            assertParamExists('updateReview', 'reviewDTO', reviewDTO)
            const localVarPath = `/api/facility-detail/{facilityId}/reviews/{reviewId}`
                .replace(`{${"facilityId"}}`, encodeURIComponent(String(facilityId)))
                .replace(`{${"reviewId"}}`, encodeURIComponent(String(reviewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewControllerApi - functional programming interface
 * @export
 */
export const ReviewControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} facilityId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReview(facilityId: string, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(facilityId, reviewDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.createReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReview(facilityId: string, reviewId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(facilityId, reviewId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.deleteReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReviewsByFacility(facilityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReviewsByFacility(facilityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.getReviewsByFacility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReview(facilityId: string, reviewId: number, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(facilityId, reviewId, reviewDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReviewControllerApi.updateReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReviewControllerApi - factory interface
 * @export
 */
export const ReviewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} facilityId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReview(facilityId: string, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig): AxiosPromise<ReviewDTO> {
            return localVarFp.createReview(facilityId, reviewDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReview(facilityId: string, reviewId: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.deleteReview(facilityId, reviewId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReviewsByFacility(facilityId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getReviewsByFacility(facilityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} facilityId 
         * @param {number} reviewId 
         * @param {ReviewDTO} reviewDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReview(facilityId: string, reviewId: number, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig): AxiosPromise<ReviewDTO> {
            return localVarFp.updateReview(facilityId, reviewId, reviewDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewControllerApi - object-oriented interface
 * @export
 * @class ReviewControllerApi
 * @extends {BaseAPI}
 */
export class ReviewControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} facilityId 
     * @param {ReviewDTO} reviewDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public createReview(facilityId: string, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).createReview(facilityId, reviewDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} facilityId 
     * @param {number} reviewId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public deleteReview(facilityId: string, reviewId: number, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).deleteReview(facilityId, reviewId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} facilityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public getReviewsByFacility(facilityId: string, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).getReviewsByFacility(facilityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} facilityId 
     * @param {number} reviewId 
     * @param {ReviewDTO} reviewDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewControllerApi
     */
    public updateReview(facilityId: string, reviewId: number, reviewDTO: ReviewDTO, options?: RawAxiosRequestConfig) {
        return ReviewControllerApiFp(this.configuration).updateReview(facilityId, reviewId, reviewDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagControllerApi.getTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: RawAxiosRequestConfig): AxiosPromise<Array<TagDTO>> {
            return localVarFp.getTags(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public getTags(options?: RawAxiosRequestConfig) {
        return TagControllerApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * UserId를 이용해 비밀번호를 변경합니다
         * @summary 비밀번호 변경
         * @param {string} userId 
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (userId: string, changePasswordDTO: ChangePasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changePassword', 'userId', userId)
            // verify required parameter 'changePasswordDTO' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDTO', changePasswordDTO)
            const localVarPath = `/api/user/password/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserId를 이용해 프로필 사진을 변경합니다
         * @summary 프로필 사진 변경
         * @param {string} userId 
         * @param {File} [multipartFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProfile: async (userId: string, multipartFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('changeProfile', 'userId', userId)
            const localVarPath = `/api/user/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (multipartFile !== undefined) { 
                localVarFormParams.append('multipartFile', multipartFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserId를 이용해 회원정보를 삭제합니다
         * @summary 회원 탈퇴
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/api/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserId를 이용해 회원정보를 조회합니다
         * @summary 회원 정보 조회
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMyInformation: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findMyInformation', 'userId', userId)
            const localVarPath = `/api/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
         * @summary 회원가입
         * @param {UserJoinDTO} userJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        join: async (userJoinDTO: UserJoinDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userJoinDTO' is not null or undefined
            assertParamExists('join', 'userJoinDTO', userJoinDTO)
            const localVarPath = `/api/user/join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userJoinDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 이메일, 암호를 입력하여 로그인합니다
         * @summary 로그인
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (userLoginDTO: UserLoginDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginDTO' is not null or undefined
            assertParamExists('login', 'userLoginDTO', userLoginDTO)
            const localVarPath = `/api/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 로그아웃을 합니다.
         * @summary 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('logout', 'authorization', authorization)
            const localVarPath = `/api/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resignAccessTokenByCookie: async (refreshToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('resignAccessTokenByCookie', 'refreshToken', refreshToken)
            const localVarPath = `/api/user/refresh/cookie`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resignAccessTokenByHeader: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('resignAccessTokenByHeader', 'authorization', authorization)
            const localVarPath = `/api/user/refresh/header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserId를 이용해 소개글을 변경합니다
         * @summary 소개글 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDescription: async (userId: string, userChangeInfoDTO: UserChangeInfoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateDescription', 'userId', userId)
            // verify required parameter 'userChangeInfoDTO' is not null or undefined
            assertParamExists('updateDescription', 'userChangeInfoDTO', userChangeInfoDTO)
            const localVarPath = `/api/user/description/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userChangeInfoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
         * @summary 닉네임 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickname: async (userId: string, userChangeInfoDTO: UserChangeInfoDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateNickname', 'userId', userId)
            // verify required parameter 'userChangeInfoDTO' is not null or undefined
            assertParamExists('updateNickname', 'userChangeInfoDTO', userChangeInfoDTO)
            const localVarPath = `/api/user/nickname/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userChangeInfoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * UserId를 이용해 비밀번호를 변경합니다
         * @summary 비밀번호 변경
         * @param {string} userId 
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(userId: string, changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(userId, changePasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * UserId를 이용해 프로필 사진을 변경합니다
         * @summary 프로필 사진 변경
         * @param {string} userId 
         * @param {File} [multipartFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeProfile(userId: string, multipartFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeProfile(userId, multipartFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.changeProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * UserId를 이용해 회원정보를 삭제합니다
         * @summary 회원 탈퇴
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * UserId를 이용해 회원정보를 조회합니다
         * @summary 회원 정보 조회
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMyInformation(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMyInformation(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.findMyInformation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
         * @summary 회원가입
         * @param {UserJoinDTO} userJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async join(userJoinDTO: UserJoinDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.join(userJoinDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.join']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 이메일, 암호를 입력하여 로그인합니다
         * @summary 로그인
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(userLoginDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 로그아웃을 합니다.
         * @summary 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resignAccessTokenByCookie(refreshToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resignAccessTokenByCookie(refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.resignAccessTokenByCookie']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resignAccessTokenByHeader(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resignAccessTokenByHeader(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.resignAccessTokenByHeader']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * UserId를 이용해 소개글을 변경합니다
         * @summary 소개글 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDescription(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDescription(userId, userChangeInfoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
         * @summary 닉네임 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNickname(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNickname(userId, userChangeInfoDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateNickname']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * UserId를 이용해 비밀번호를 변경합니다
         * @summary 비밀번호 변경
         * @param {string} userId 
         * @param {ChangePasswordDTO} changePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(userId: string, changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changePassword(userId, changePasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * UserId를 이용해 프로필 사진을 변경합니다
         * @summary 프로필 사진 변경
         * @param {string} userId 
         * @param {File} [multipartFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProfile(userId: string, multipartFile?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.changeProfile(userId, multipartFile, options).then((request) => request(axios, basePath));
        },
        /**
         * UserId를 이용해 회원정보를 삭제합니다
         * @summary 회원 탈퇴
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * UserId를 이용해 회원정보를 조회합니다
         * @summary 회원 정보 조회
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMyInformation(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findMyInformation(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
         * @summary 회원가입
         * @param {UserJoinDTO} userJoinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        join(userJoinDTO: UserJoinDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.join(userJoinDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 이메일, 암호를 입력하여 로그인합니다
         * @summary 로그인
         * @param {UserLoginDTO} userLoginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.login(userLoginDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 로그아웃을 합니다.
         * @summary 로그아웃
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} refreshToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resignAccessTokenByCookie(refreshToken: string, options?: RawAxiosRequestConfig): AxiosPromise<JwtToken> {
            return localVarFp.resignAccessTokenByCookie(refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
         * @summary 토큰 재발급
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resignAccessTokenByHeader(authorization: string, options?: RawAxiosRequestConfig): AxiosPromise<JwtToken> {
            return localVarFp.resignAccessTokenByHeader(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * UserId를 이용해 소개글을 변경합니다
         * @summary 소개글 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDescription(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDescription(userId, userChangeInfoDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
         * @summary 닉네임 변경
         * @param {string} userId 
         * @param {UserChangeInfoDTO} userChangeInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNickname(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNickname(userId, userChangeInfoDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * UserId를 이용해 비밀번호를 변경합니다
     * @summary 비밀번호 변경
     * @param {string} userId 
     * @param {ChangePasswordDTO} changePasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public changePassword(userId: string, changePasswordDTO: ChangePasswordDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).changePassword(userId, changePasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * UserId를 이용해 프로필 사진을 변경합니다
     * @summary 프로필 사진 변경
     * @param {string} userId 
     * @param {File} [multipartFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public changeProfile(userId: string, multipartFile?: File, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).changeProfile(userId, multipartFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * UserId를 이용해 회원정보를 삭제합니다
     * @summary 회원 탈퇴
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * UserId를 이용해 회원정보를 조회합니다
     * @summary 회원 정보 조회
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public findMyInformation(userId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).findMyInformation(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
     * @summary 회원가입
     * @param {UserJoinDTO} userJoinDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public join(userJoinDTO: UserJoinDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).join(userJoinDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 이메일, 암호를 입력하여 로그인합니다
     * @summary 로그인
     * @param {UserLoginDTO} userLoginDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public login(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).login(userLoginDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 로그아웃을 합니다.
     * @summary 로그아웃
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public logout(authorization: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).logout(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} refreshToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public resignAccessTokenByCookie(refreshToken: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).resignAccessTokenByCookie(refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public resignAccessTokenByHeader(authorization: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).resignAccessTokenByHeader(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * UserId를 이용해 소개글을 변경합니다
     * @summary 소개글 변경
     * @param {string} userId 
     * @param {UserChangeInfoDTO} userChangeInfoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateDescription(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateDescription(userId, userChangeInfoDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
     * @summary 닉네임 변경
     * @param {string} userId 
     * @param {UserChangeInfoDTO} userChangeInfoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateNickname(userId: string, userChangeInfoDTO: UserChangeInfoDTO, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateNickname(userId, userChangeInfoDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



