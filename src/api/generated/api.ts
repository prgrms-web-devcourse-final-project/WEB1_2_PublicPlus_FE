/* tslint:disable */
/* eslint-disable */
/**
 * PublicPlus
 * 공공체육시설 활성화 사이트 공공플러스입니다!
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap
} from './base';

/**
 *
 * @export
 * @interface ActivityCreateDTO
 */
export interface ActivityCreateDTO {
  /**
   * 모임의 제목
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  title?: string;
  /**
   * 구글 캘린더의 Event ID
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  eventId?: string;
  /**
   * 모임에 대한 설명
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  description?: string;
  /**
   * 모임 장소
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  location?: string;
  /**
   * 모임 시작 시간 (ISO 8601 형식)
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  startTime?: string;
  /**
   * 모임 종료 시간 (ISO 8601 형식)
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  endTime?: string;
  /**
   * 구글 캘린더 ID
   * @type {string}
   * @memberof ActivityCreateDTO
   */
  googleCalenderId?: string;
  /**
   * 모임 최대 참석자 수
   * @type {number}
   * @memberof ActivityCreateDTO
   */
  maxAttendees?: number;
}
/**
 *
 * @export
 * @interface ActivityResponseDTO
 */
export interface ActivityResponseDTO {
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  endTime?: string;
  /**
   *
   * @type {number}
   * @memberof ActivityResponseDTO
   */
  maxParticipants?: number;
  /**
   *
   * @type {number}
   * @memberof ActivityResponseDTO
   */
  currentParticipants?: number;
  /**
   *
   * @type {string}
   * @memberof ActivityResponseDTO
   */
  eventId?: string;
}
/**
 *
 * @export
 * @interface ActivityUpdateDTO
 */
export interface ActivityUpdateDTO {
  /**
   *
   * @type {number}
   * @memberof ActivityUpdateDTO
   */
  activityId?: number;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  eventId?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  location?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  startTime?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  endTime?: string;
  /**
   *
   * @type {string}
   * @memberof ActivityUpdateDTO
   */
  googleCalenderId?: string;
  /**
   *
   * @type {number}
   * @memberof ActivityUpdateDTO
   */
  maxAttendees?: number;
}
/**
 *
 * @export
 * @interface ChangePasswordDTO
 */
export interface ChangePasswordDTO {
  /**
   * 사용자 이메일
   * @type {string}
   * @memberof ChangePasswordDTO
   */
  email?: string;
  /**
   * 사용자 비밀번호
   * @type {string}
   * @memberof ChangePasswordDTO
   */
  changePassword?: string;
  /**
   * 비밀번호 확인
   * @type {string}
   * @memberof ChangePasswordDTO
   */
  checkChangePassword?: string;
}
/**
 *
 * @export
 * @interface ClassInfo
 */
export interface ClassInfo {
  /**
   *
   * @type {boolean}
   * @memberof ClassInfo
   */
  ignoreCase?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof ClassInfo
   */
  names?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof ClassInfo
   */
  enum?: boolean;
  /**
   *
   * @type {Array<FieldInfo>}
   * @memberof ClassInfo
   */
  fieldInfos?: Array<FieldInfo>;
}
/**
 *
 * @export
 * @interface DateTime
 */
export interface DateTime {
  /**
   *
   * @type {number}
   * @memberof DateTime
   */
  value?: number;
  /**
   *
   * @type {boolean}
   * @memberof DateTime
   */
  dateOnly?: boolean;
  /**
   *
   * @type {number}
   * @memberof DateTime
   */
  timeZoneShift?: number;
}
/**
 *
 * @export
 * @interface EntryPoint
 */
export interface EntryPoint {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EntryPoint
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  accessCode?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EntryPoint
   */
  entryPointFeatures?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  entryPointType?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  label?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  meetingCode?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  passcode?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  password?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  pin?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  regionCode?: string;
  /**
   *
   * @type {string}
   * @memberof EntryPoint
   */
  uri?: string;
  /**
   *
   * @type {object}
   * @memberof EntryPoint
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EntryPoint
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EntryPoint
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  httpStatus?: ErrorResponseHttpStatusEnum;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  message?: string;
}

export const ErrorResponseHttpStatusEnum = {
  _100Continue: '100 CONTINUE',
  _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
  _102Processing: '102 PROCESSING',
  _103EarlyHints: '103 EARLY_HINTS',
  _103Checkpoint: '103 CHECKPOINT',
  _200Ok: '200 OK',
  _201Created: '201 CREATED',
  _202Accepted: '202 ACCEPTED',
  _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
  _204NoContent: '204 NO_CONTENT',
  _205ResetContent: '205 RESET_CONTENT',
  _206PartialContent: '206 PARTIAL_CONTENT',
  _207MultiStatus: '207 MULTI_STATUS',
  _208AlreadyReported: '208 ALREADY_REPORTED',
  _226ImUsed: '226 IM_USED',
  _300MultipleChoices: '300 MULTIPLE_CHOICES',
  _301MovedPermanently: '301 MOVED_PERMANENTLY',
  _302Found: '302 FOUND',
  _302MovedTemporarily: '302 MOVED_TEMPORARILY',
  _303SeeOther: '303 SEE_OTHER',
  _304NotModified: '304 NOT_MODIFIED',
  _305UseProxy: '305 USE_PROXY',
  _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
  _308PermanentRedirect: '308 PERMANENT_REDIRECT',
  _400BadRequest: '400 BAD_REQUEST',
  _401Unauthorized: '401 UNAUTHORIZED',
  _402PaymentRequired: '402 PAYMENT_REQUIRED',
  _403Forbidden: '403 FORBIDDEN',
  _404NotFound: '404 NOT_FOUND',
  _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
  _406NotAcceptable: '406 NOT_ACCEPTABLE',
  _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
  _408RequestTimeout: '408 REQUEST_TIMEOUT',
  _409Conflict: '409 CONFLICT',
  _410Gone: '410 GONE',
  _411LengthRequired: '411 LENGTH_REQUIRED',
  _412PreconditionFailed: '412 PRECONDITION_FAILED',
  _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
  _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
  _414UriTooLong: '414 URI_TOO_LONG',
  _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
  _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
  _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
  _417ExpectationFailed: '417 EXPECTATION_FAILED',
  _418IAmATeapot: '418 I_AM_A_TEAPOT',
  _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
  _420MethodFailure: '420 METHOD_FAILURE',
  _421DestinationLocked: '421 DESTINATION_LOCKED',
  _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
  _423Locked: '423 LOCKED',
  _424FailedDependency: '424 FAILED_DEPENDENCY',
  _425TooEarly: '425 TOO_EARLY',
  _426UpgradeRequired: '426 UPGRADE_REQUIRED',
  _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
  _429TooManyRequests: '429 TOO_MANY_REQUESTS',
  _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
  _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
  _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
  _501NotImplemented: '501 NOT_IMPLEMENTED',
  _502BadGateway: '502 BAD_GATEWAY',
  _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
  _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
  _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
  _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
  _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
  _508LoopDetected: '508 LOOP_DETECTED',
  _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
  _510NotExtended: '510 NOT_EXTENDED',
  _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type ErrorResponseHttpStatusEnum =
  (typeof ErrorResponseHttpStatusEnum)[keyof typeof ErrorResponseHttpStatusEnum];

/**
 *
 * @export
 * @interface ErrorResponseDTO
 */
export interface ErrorResponseDTO {
  /**
   * 에러 코드
   * @type {string}
   * @memberof ErrorResponseDTO
   */
  errorCode?: string;
  /**
   * 에러 메시지
   * @type {string}
   * @memberof ErrorResponseDTO
   */
  message?: string;
  /**
   * 에러에 대한 세부 설명
   * @type {string}
   * @memberof ErrorResponseDTO
   */
  details?: string;
}
/**
 *
 * @export
 * @interface Event
 */
export interface Event {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof Event
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  anyoneCanAddSelf?: boolean;
  /**
   *
   * @type {Array<EventAttachment>}
   * @memberof Event
   */
  attachments?: Array<EventAttachment>;
  /**
   *
   * @type {Array<EventAttendee>}
   * @memberof Event
   */
  attendees?: Array<EventAttendee>;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  attendeesOmitted?: boolean;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  colorId?: string;
  /**
   *
   * @type {EventConferenceData}
   * @memberof Event
   */
  conferenceData?: EventConferenceData;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  created?: string;
  /**
   *
   * @type {EventCreator}
   * @memberof Event
   */
  creator?: EventCreator;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  description?: string;
  /**
   *
   * @type {EventEnd}
   * @memberof Event
   */
  end?: EventEnd;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  endTimeUnspecified?: boolean;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  etag?: string;
  /**
   *
   * @type {EventExtendedProperties}
   * @memberof Event
   */
  extendedProperties?: EventExtendedProperties;
  /**
   *
   * @type {EventGadget}
   * @memberof Event
   */
  gadget?: EventGadget;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  guestsCanInviteOthers?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  guestsCanModify?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  guestsCanSeeOtherGuests?: boolean;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  hangoutLink?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  htmlLink?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  kind?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  location?: string;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  locked?: boolean;
  /**
   *
   * @type {EventCreator}
   * @memberof Event
   */
  organizer?: EventCreator;
  /**
   *
   * @type {EventEnd}
   * @memberof Event
   */
  originalStartTime?: EventEnd;
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  privateCopy?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof Event
   */
  recurrence?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  recurringEventId?: string;
  /**
   *
   * @type {EventReminders}
   * @memberof Event
   */
  reminders?: EventReminders;
  /**
   *
   * @type {number}
   * @memberof Event
   */
  sequence?: number;
  /**
   *
   * @type {EventSource}
   * @memberof Event
   */
  source?: EventSource;
  /**
   *
   * @type {EventEnd}
   * @memberof Event
   */
  start?: EventEnd;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  summary?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  transparency?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  visibility?: string;
  /**
   *
   * @type {string}
   * @memberof Event
   */
  icalUID?: string;
  /**
   *
   * @type {object}
   * @memberof Event
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof Event
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof Event
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventAttachment
 */
export interface EventAttachment {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventAttachment
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventAttachment
   */
  fileId?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttachment
   */
  fileUrl?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttachment
   */
  iconLink?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttachment
   */
  mimeType?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttachment
   */
  title?: string;
  /**
   *
   * @type {object}
   * @memberof EventAttachment
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventAttachment
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventAttachment
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventAttendee
 */
export interface EventAttendee {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventAttendee
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {number}
   * @memberof EventAttendee
   */
  additionalGuests?: number;
  /**
   *
   * @type {string}
   * @memberof EventAttendee
   */
  comment?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttendee
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttendee
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof EventAttendee
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof EventAttendee
   */
  optional?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof EventAttendee
   */
  organizer?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof EventAttendee
   */
  resource?: boolean;
  /**
   *
   * @type {string}
   * @memberof EventAttendee
   */
  responseStatus?: string;
  /**
   *
   * @type {boolean}
   * @memberof EventAttendee
   */
  self?: boolean;
  /**
   *
   * @type {object}
   * @memberof EventAttendee
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventAttendee
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventAttendee
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceData
 */
export interface EventConferenceData {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceData
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventConferenceData
   */
  conferenceId?: string;
  /**
   *
   * @type {EventConferenceDataConferenceSolution}
   * @memberof EventConferenceData
   */
  conferenceSolution?: EventConferenceDataConferenceSolution;
  /**
   *
   * @type {EventConferenceDataCreateRequest}
   * @memberof EventConferenceData
   */
  createRequest?: EventConferenceDataCreateRequest;
  /**
   *
   * @type {Array<EntryPoint>}
   * @memberof EventConferenceData
   */
  entryPoints?: Array<EntryPoint>;
  /**
   *
   * @type {string}
   * @memberof EventConferenceData
   */
  notes?: string;
  /**
   *
   * @type {EventConferenceDataParameters}
   * @memberof EventConferenceData
   */
  parameters?: EventConferenceDataParameters;
  /**
   *
   * @type {string}
   * @memberof EventConferenceData
   */
  signature?: string;
  /**
   *
   * @type {object}
   * @memberof EventConferenceData
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceData
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceData
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataConferenceSolution
 */
export interface EventConferenceDataConferenceSolution {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataConferenceSolution
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventConferenceDataConferenceSolution
   */
  iconUri?: string;
  /**
   *
   * @type {EventConferenceDataConferenceSolutionKey}
   * @memberof EventConferenceDataConferenceSolution
   */
  key?: EventConferenceDataConferenceSolutionKey;
  /**
   *
   * @type {string}
   * @memberof EventConferenceDataConferenceSolution
   */
  name?: string;
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataConferenceSolution
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataConferenceSolution
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataConferenceSolution
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataConferenceSolutionKey
 */
export interface EventConferenceDataConferenceSolutionKey {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataConferenceSolutionKey
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventConferenceDataConferenceSolutionKey
   */
  type?: string;
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataConferenceSolutionKey
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataConferenceSolutionKey
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataConferenceSolutionKey
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataCreateRequest
 */
export interface EventConferenceDataCreateRequest {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataCreateRequest
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {EventConferenceDataConferenceSolutionKey}
   * @memberof EventConferenceDataCreateRequest
   */
  conferenceSolutionKey?: EventConferenceDataConferenceSolutionKey;
  /**
   *
   * @type {string}
   * @memberof EventConferenceDataCreateRequest
   */
  requestId?: string;
  /**
   *
   * @type {EventConferenceDataCreateRequestStatus}
   * @memberof EventConferenceDataCreateRequest
   */
  status?: EventConferenceDataCreateRequestStatus;
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataCreateRequest
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataCreateRequest
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataCreateRequest
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataCreateRequestStatus
 */
export interface EventConferenceDataCreateRequestStatus {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataCreateRequestStatus
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventConferenceDataCreateRequestStatus
   */
  statusCode?: string;
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataCreateRequestStatus
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataCreateRequestStatus
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataCreateRequestStatus
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataParameters
 */
export interface EventConferenceDataParameters {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataParameters
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {EventConferenceDataParametersAddOnParameters}
   * @memberof EventConferenceDataParameters
   */
  addOnParameters?: EventConferenceDataParametersAddOnParameters;
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataParameters
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataParameters
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataParameters
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventConferenceDataParametersAddOnParameters
 */
export interface EventConferenceDataParametersAddOnParameters {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventConferenceDataParametersAddOnParameters
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EventConferenceDataParametersAddOnParameters
   */
  parameters?: { [key: string]: string };
  /**
   *
   * @type {object}
   * @memberof EventConferenceDataParametersAddOnParameters
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventConferenceDataParametersAddOnParameters
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventConferenceDataParametersAddOnParameters
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventCreator
 */
export interface EventCreator {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventCreator
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventCreator
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof EventCreator
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof EventCreator
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof EventCreator
   */
  self?: boolean;
  /**
   *
   * @type {object}
   * @memberof EventCreator
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventCreator
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventCreator
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventEnd
 */
export interface EventEnd {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventEnd
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventEnd
   */
  date?: string;
  /**
   *
   * @type {string}
   * @memberof EventEnd
   */
  dateTime?: string;
  /**
   *
   * @type {string}
   * @memberof EventEnd
   */
  timeZone?: string;
  /**
   *
   * @type {object}
   * @memberof EventEnd
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventEnd
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventEnd
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventExtendedProperties
 */
export interface EventExtendedProperties {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventExtendedProperties
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EventExtendedProperties
   */
  shared?: { [key: string]: string };
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EventExtendedProperties
   */
  private?: { [key: string]: string };
  /**
   *
   * @type {object}
   * @memberof EventExtendedProperties
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventExtendedProperties
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventExtendedProperties
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventGadget
 */
export interface EventGadget {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventGadget
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventGadget
   */
  display?: string;
  /**
   *
   * @type {number}
   * @memberof EventGadget
   */
  height?: number;
  /**
   *
   * @type {string}
   * @memberof EventGadget
   */
  iconLink?: string;
  /**
   *
   * @type {string}
   * @memberof EventGadget
   */
  link?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EventGadget
   */
  preferences?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof EventGadget
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof EventGadget
   */
  type?: string;
  /**
   *
   * @type {number}
   * @memberof EventGadget
   */
  width?: number;
  /**
   *
   * @type {object}
   * @memberof EventGadget
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventGadget
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventGadget
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventReminder
 */
export interface EventReminder {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventReminder
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventReminder
   */
  method?: string;
  /**
   *
   * @type {number}
   * @memberof EventReminder
   */
  minutes?: number;
  /**
   *
   * @type {object}
   * @memberof EventReminder
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventReminder
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventReminder
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventReminders
 */
export interface EventReminders {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventReminders
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {Array<EventReminder>}
   * @memberof EventReminders
   */
  overrides?: Array<EventReminder>;
  /**
   *
   * @type {boolean}
   * @memberof EventReminders
   */
  useDefault?: boolean;
  /**
   *
   * @type {object}
   * @memberof EventReminders
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventReminders
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventReminders
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface EventSource
 */
export interface EventSource {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof EventSource
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof EventSource
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof EventSource
   */
  url?: string;
  /**
   *
   * @type {object}
   * @memberof EventSource
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof EventSource
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof EventSource
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface Events
 */
export interface Events {
  [key: string]: object | any;

  /**
   *
   * @type {ClassInfo}
   * @memberof Events
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  accessRole?: string;
  /**
   *
   * @type {Array<EventReminder>}
   * @memberof Events
   */
  defaultReminders?: Array<EventReminder>;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  etag?: string;
  /**
   *
   * @type {Array<Event>}
   * @memberof Events
   */
  items?: Array<Event>;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  kind?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  nextPageToken?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  nextSyncToken?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  summary?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  timeZone?: string;
  /**
   *
   * @type {string}
   * @memberof Events
   */
  updated?: string;
  /**
   *
   * @type {object}
   * @memberof Events
   */
  factory?: object;
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof Events
   */
  unknownKeys?: { [key: string]: object };
  /**
   *
   * @type {boolean}
   * @memberof Events
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface FacilityDetailsResponseDTO
 */
export interface FacilityDetailsResponseDTO {
  /**
   * 시설 고유 ID
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityId?: string;
  /**
   * 시설 이름
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityName?: string;
  /**
   * 시설 카테고리
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityCategory?: FacilityDetailsResponseDTOFacilityCategoryEnum;
  /**
   * 시설 지역
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  area?: string;
  /**
   * 무료/유료 여부
   * @type {boolean}
   * @memberof FacilityDetailsResponseDTO
   */
  priceType?: boolean;
  /**
   * 시설 이미지 URL
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityImage?: string;
  /**
   * 예약 시작 날짜
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  reservationStartDate?: string;
  /**
   * 예약 종료 날짜
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  reservationEndDate?: string;
  /**
   * 시설 전화번호
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityNumber?: string;
  /**
   * 시설 예약 URL
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  reservationURL?: string;
  /**
   * 시설 상세 주소
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityLocation?: string;
  /**
   * 시설 설명
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  facilityDescription?: string;
  /**
   * 서비스 시작 날짜
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  serviceStartDate?: string;
  /**
   * 서비스 종료 날짜
   * @type {string}
   * @memberof FacilityDetailsResponseDTO
   */
  serviceEndDate?: string;
  /**
   * 위도
   * @type {number}
   * @memberof FacilityDetailsResponseDTO
   */
  latitude?: number;
  /**
   * 경도
   * @type {number}
   * @memberof FacilityDetailsResponseDTO
   */
  longitude?: number;
}

export const FacilityDetailsResponseDTOFacilityCategoryEnum = {
  FootballField: 'FOOTBALL_FIELD',
  FutsalField: 'FUTSAL_FIELD',
  FootVolleyballField: 'FOOT_VOLLEYBALL_FIELD',
  BaseballField: 'BASEBALL_FIELD',
  TennisField: 'TENNIS_FIELD',
  BasketballField: 'BASKETBALL_FIELD',
  VolleyballField: 'VOLLEYBALL_FIELD',
  MultipurposeField: 'MULTIPURPOSE_FIELD',
  SportsField: 'SPORTS_FIELD',
  Gym: 'GYM',
  BadmintonField: 'BADMINTON_FIELD',
  TableTennisField: 'TABLE_TENNIS_FIELD',
  EducationalFacility: 'EDUCATIONAL_FACILITY',
  SwimmingPool: 'SWIMMING_POOL',
  GolfField: 'GOLF_FIELD'
} as const;

export type FacilityDetailsResponseDTOFacilityCategoryEnum =
  (typeof FacilityDetailsResponseDTOFacilityCategoryEnum)[keyof typeof FacilityDetailsResponseDTOFacilityCategoryEnum];

/**
 *
 * @export
 * @interface FacilityDetailsUpdateDTO
 */
export interface FacilityDetailsUpdateDTO {
  /**
   * 시설 고유 ID
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityId?: string;
  /**
   * 시설 이름
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityName?: string;
  /**
   * 시설 카테고리
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityCategory?: FacilityDetailsUpdateDTOFacilityCategoryEnum;
  /**
   * 시설 지역
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  area?: string;
  /**
   * 무료(true) / 유료(false)
   * @type {boolean}
   * @memberof FacilityDetailsUpdateDTO
   */
  priceType?: boolean;
  /**
   * 시설 이미지 URL
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityImage?: string;
  /**
   * 서비스 시작 날짜
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  reservationStartDate?: string;
  /**
   * 서비스 종료 날짜
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  reservationEndDate?: string;
  /**
   * 시설 전화번호
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityNumber?: string;
  /**
   * 예약 URL
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  reservationURL?: string;
  /**
   * 시설 상세 주소
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityLocation?: string;
  /**
   * 시설 설명
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  facilityDescription?: string;
  /**
   * 서비스 시작 날짜 (String 형식)
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  serviceStartDate?: string;
  /**
   * 서비스 종료 날짜 (String 형식)
   * @type {string}
   * @memberof FacilityDetailsUpdateDTO
   */
  serviceEndDate?: string;
}

export const FacilityDetailsUpdateDTOFacilityCategoryEnum = {
  FootballField: 'FOOTBALL_FIELD',
  FutsalField: 'FUTSAL_FIELD',
  FootVolleyballField: 'FOOT_VOLLEYBALL_FIELD',
  BaseballField: 'BASEBALL_FIELD',
  TennisField: 'TENNIS_FIELD',
  BasketballField: 'BASKETBALL_FIELD',
  VolleyballField: 'VOLLEYBALL_FIELD',
  MultipurposeField: 'MULTIPURPOSE_FIELD',
  SportsField: 'SPORTS_FIELD',
  Gym: 'GYM',
  BadmintonField: 'BADMINTON_FIELD',
  TableTennisField: 'TABLE_TENNIS_FIELD',
  EducationalFacility: 'EDUCATIONAL_FACILITY',
  SwimmingPool: 'SWIMMING_POOL',
  GolfField: 'GOLF_FIELD'
} as const;

export type FacilityDetailsUpdateDTOFacilityCategoryEnum =
  (typeof FacilityDetailsUpdateDTOFacilityCategoryEnum)[keyof typeof FacilityDetailsUpdateDTOFacilityCategoryEnum];

/**
 *
 * @export
 * @interface FacilityFilterDTO
 */
export interface FacilityFilterDTO {
  /**
   * 시설 이름
   * @type {string}
   * @memberof FacilityFilterDTO
   */
  facilityName?: string;
  /**
   * 시설 카테고리
   * @type {string}
   * @memberof FacilityFilterDTO
   */
  facilityCategory?: string;
  /**
   * 시설 지역
   * @type {string}
   * @memberof FacilityFilterDTO
   */
  area?: string;
  /**
   * 시설 가격 유형(무료/유료)
   * @type {boolean}
   * @memberof FacilityFilterDTO
   */
  priceType?: boolean;
}
/**
 *
 * @export
 * @interface FacilityLocationDTO
 */
export interface FacilityLocationDTO {
  /**
   * 검색할 시설의 위도
   * @type {number}
   * @memberof FacilityLocationDTO
   */
  latitude?: number;
  /**
   * 검색할 시설의 경도
   * @type {number}
   * @memberof FacilityLocationDTO
   */
  longitude?: number;
  /**
   * 검색할 반경 (킬로미터 단위)
   * @type {number}
   * @memberof FacilityLocationDTO
   */
  radius?: number;
}
/**
 *
 * @export
 * @interface FacilityResponseDTO
 */
export interface FacilityResponseDTO {
  /**
   * 시설 ID
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  facilityId?: string;
  /**
   * 시설 이름
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  facilityName?: string;
  /**
   * 시설 카테고리
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  facilityCategory?: FacilityResponseDTOFacilityCategoryEnum;
  /**
   * 시설 지역
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  area?: string;
  /**
   * 시설 가격 정보
   * @type {boolean}
   * @memberof FacilityResponseDTO
   */
  priceType?: boolean;
  /**
   * 시설 이미지 URL
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  facilityImage?: string;
  /**
   * 예약 시작 날짜
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  reservationStartDate?: string;
  /**
   * 예약 종료 날짜
   * @type {string}
   * @memberof FacilityResponseDTO
   */
  reservationEndDate?: string;
}

export const FacilityResponseDTOFacilityCategoryEnum = {
  FootballField: 'FOOTBALL_FIELD',
  FutsalField: 'FUTSAL_FIELD',
  FootVolleyballField: 'FOOT_VOLLEYBALL_FIELD',
  BaseballField: 'BASEBALL_FIELD',
  TennisField: 'TENNIS_FIELD',
  BasketballField: 'BASKETBALL_FIELD',
  VolleyballField: 'VOLLEYBALL_FIELD',
  MultipurposeField: 'MULTIPURPOSE_FIELD',
  SportsField: 'SPORTS_FIELD',
  Gym: 'GYM',
  BadmintonField: 'BADMINTON_FIELD',
  TableTennisField: 'TABLE_TENNIS_FIELD',
  EducationalFacility: 'EDUCATIONAL_FACILITY',
  SwimmingPool: 'SWIMMING_POOL',
  GolfField: 'GOLF_FIELD'
} as const;

export type FacilityResponseDTOFacilityCategoryEnum =
  (typeof FacilityResponseDTOFacilityCategoryEnum)[keyof typeof FacilityResponseDTOFacilityCategoryEnum];

/**
 *
 * @export
 * @interface FieldInfo
 */
export interface FieldInfo {
  /**
   *
   * @type {FieldInfoField}
   * @memberof FieldInfo
   */
  field?: FieldInfoField;
  /**
   *
   * @type {string}
   * @memberof FieldInfo
   */
  name?: string;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfo
   */
  primitive?: boolean;
  /**
   *
   * @type {FieldInfoFieldGenericType}
   * @memberof FieldInfo
   */
  genericType?: FieldInfoFieldGenericType;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfo
   */
  final?: boolean;
  /**
   *
   * @type {ClassInfo}
   * @memberof FieldInfo
   */
  classInfo?: ClassInfo;
  /**
   *
   * @type {Array<FieldInfoTersMethodForField>}
   * @memberof FieldInfo
   */
  tersMethodForField?: Array<FieldInfoTersMethodForField>;
}
/**
 *
 * @export
 * @interface FieldInfoDeclaringExecutable
 */
export interface FieldInfoDeclaringExecutable {
  /**
   *
   * @type {string}
   * @memberof FieldInfoDeclaringExecutable
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof FieldInfoDeclaringExecutable
   */
  modifiers?: number;
  /**
   *
   * @type {Array<FieldInfoDeclaringExecutableTypeParameters>}
   * @memberof FieldInfoDeclaringExecutable
   */
  typeParameters?: Array<FieldInfoDeclaringExecutableTypeParameters>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoDeclaringExecutable
   */
  synthetic?: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoDeclaringExecutable
   */
  declaredAnnotations?: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoDeclaringExecutable
   */
  varArgs?: boolean;
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoDeclaringExecutable
   */
  annotatedParameterTypes?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {number}
   * @memberof FieldInfoDeclaringExecutable
   */
  parameterCount?: number;
  /**
   *
   * @type {Array<Array<object>>}
   * @memberof FieldInfoDeclaringExecutable
   */
  parameterAnnotations?: Array<Array<object>>;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoDeclaringExecutable
   */
  genericParameterTypes?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoDeclaringExecutable
   */
  genericExceptionTypes?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoDeclaringExecutable
   */
  annotatedReturnType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoDeclaringExecutable
   */
  annotatedReceiverType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoDeclaringExecutable
   */
  annotatedExceptionTypes?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoDeclaringExecutable
   */
  annotations?: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoDeclaringExecutable
   * @deprecated
   */
  accessible?: boolean;
}
/**
 *
 * @export
 * @interface FieldInfoDeclaringExecutableTypeParameters
 */
export interface FieldInfoDeclaringExecutableTypeParameters {
  /**
   *
   * @type {object}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  genericDeclaration?: object;
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  annotatedBounds?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {string}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  name?: string;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  bounds?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {string}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  typeName?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  annotations?: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoDeclaringExecutableTypeParameters
   */
  declaredAnnotations?: Array<object>;
}
/**
 *
 * @export
 * @interface FieldInfoField
 */
export interface FieldInfoField {
  /**
   *
   * @type {string}
   * @memberof FieldInfoField
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof FieldInfoField
   */
  modifiers?: number;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoField
   */
  synthetic?: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoField
   */
  declaredAnnotations?: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoField
   * @deprecated
   */
  accessible?: boolean;
  /**
   *
   * @type {FieldInfoFieldGenericType}
   * @memberof FieldInfoField
   */
  genericType?: FieldInfoFieldGenericType;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoField
   */
  enumConstant?: boolean;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoField
   */
  annotatedType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoField
   */
  annotations?: Array<object>;
}
/**
 *
 * @export
 * @interface FieldInfoFieldAnnotatedType
 */
export interface FieldInfoFieldAnnotatedType {
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoFieldAnnotatedType
   */
  annotations?: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoFieldAnnotatedType
   */
  declaredAnnotations?: Array<object>;
  /**
   *
   * @type {FieldInfoFieldGenericType}
   * @memberof FieldInfoFieldAnnotatedType
   */
  type?: FieldInfoFieldGenericType;
}
/**
 *
 * @export
 * @interface FieldInfoFieldGenericType
 */
export interface FieldInfoFieldGenericType {
  /**
   *
   * @type {string}
   * @memberof FieldInfoFieldGenericType
   */
  typeName?: string;
}
/**
 *
 * @export
 * @interface FieldInfoParameters
 */
export interface FieldInfoParameters {
  /**
   *
   * @type {string}
   * @memberof FieldInfoParameters
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof FieldInfoParameters
   */
  modifiers?: number;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoParameters
   */
  synthetic?: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoParameters
   */
  annotations?: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoParameters
   */
  declaredAnnotations?: Array<object>;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoParameters
   */
  annotatedType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {FieldInfoFieldGenericType}
   * @memberof FieldInfoParameters
   */
  parameterizedType?: FieldInfoFieldGenericType;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoParameters
   */
  varArgs?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoParameters
   */
  namePresent?: boolean;
  /**
   *
   * @type {FieldInfoDeclaringExecutable}
   * @memberof FieldInfoParameters
   */
  declaringExecutable?: FieldInfoDeclaringExecutable;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoParameters
   */
  implicit?: boolean;
}
/**
 *
 * @export
 * @interface FieldInfoTersMethodForField
 */
export interface FieldInfoTersMethodForField {
  /**
   *
   * @type {string}
   * @memberof FieldInfoTersMethodForField
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof FieldInfoTersMethodForField
   */
  modifiers?: number;
  /**
   *
   * @type {Array<FieldInfoTypeParameters>}
   * @memberof FieldInfoTersMethodForField
   */
  typeParameters?: Array<FieldInfoTypeParameters>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoTersMethodForField
   */
  synthetic?: boolean;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoTersMethodForField
   */
  declaredAnnotations?: Array<object>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoTersMethodForField
   * @deprecated
   */
  accessible?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoTersMethodForField
   */
  varArgs?: boolean;
  /**
   *
   * @type {number}
   * @memberof FieldInfoTersMethodForField
   */
  parameterCount?: number;
  /**
   *
   * @type {Array<Array<object>>}
   * @memberof FieldInfoTersMethodForField
   */
  parameterAnnotations?: Array<Array<object>>;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoTersMethodForField
   */
  genericParameterTypes?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoTersMethodForField
   */
  genericExceptionTypes?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoTersMethodForField
   */
  default?: boolean;
  /**
   *
   * @type {FieldInfoFieldGenericType}
   * @memberof FieldInfoTersMethodForField
   */
  genericReturnType?: FieldInfoFieldGenericType;
  /**
   *
   * @type {boolean}
   * @memberof FieldInfoTersMethodForField
   */
  bridge?: boolean;
  /**
   *
   * @type {object}
   * @memberof FieldInfoTersMethodForField
   */
  defaultValue?: object;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoTersMethodForField
   */
  annotatedReturnType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoTersMethodForField
   */
  annotatedParameterTypes?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {Array<FieldInfoParameters>}
   * @memberof FieldInfoTersMethodForField
   */
  parameters?: Array<FieldInfoParameters>;
  /**
   *
   * @type {FieldInfoFieldAnnotatedType}
   * @memberof FieldInfoTersMethodForField
   */
  annotatedReceiverType?: FieldInfoFieldAnnotatedType;
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoTersMethodForField
   */
  annotatedExceptionTypes?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoTersMethodForField
   */
  annotations?: Array<object>;
}
/**
 *
 * @export
 * @interface FieldInfoTypeParameters
 */
export interface FieldInfoTypeParameters {
  /**
   *
   * @type {Array<FieldInfoFieldAnnotatedType>}
   * @memberof FieldInfoTypeParameters
   */
  annotatedBounds?: Array<FieldInfoFieldAnnotatedType>;
  /**
   *
   * @type {string}
   * @memberof FieldInfoTypeParameters
   */
  name?: string;
  /**
   *
   * @type {Array<FieldInfoFieldGenericType>}
   * @memberof FieldInfoTypeParameters
   */
  bounds?: Array<FieldInfoFieldGenericType>;
  /**
   *
   * @type {string}
   * @memberof FieldInfoTypeParameters
   */
  typeName?: string;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoTypeParameters
   */
  annotations?: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof FieldInfoTypeParameters
   */
  declaredAnnotations?: Array<object>;
}
/**
 *
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  hour?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  minute?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  second?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  nano?: number;
}
/**
 *
 * @export
 * @interface MeetingBoardRequestDTO
 */
export interface MeetingBoardRequestDTO {
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  sportType: MeetingBoardRequestDTOSportTypeEnum;
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  mbTitle: string;
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  mbContent: string;
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  mbDate: string;
  /**
   *
   * @type {LocalTime}
   * @memberof MeetingBoardRequestDTO
   */
  mbTime: LocalTime;
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  mbLocation: string;
  /**
   *
   * @type {string}
   * @memberof MeetingBoardRequestDTO
   */
  mbHost: string;
  /**
   *
   * @type {number}
   * @memberof MeetingBoardRequestDTO
   */
  maxParticipants: number;
}

export const MeetingBoardRequestDTOSportTypeEnum = {
  Badminton: 'BADMINTON',
  Baseball: 'BASEBALL',
  Basketball: 'BASKETBALL',
  Soccer: 'SOCCER',
  Swimming: 'SWIMMING',
  Tennis: 'TENNIS'
} as const;

export type MeetingBoardRequestDTOSportTypeEnum =
  (typeof MeetingBoardRequestDTOSportTypeEnum)[keyof typeof MeetingBoardRequestDTOSportTypeEnum];

/**
 *
 * @export
 * @interface NotificationCreateDTO
 */
export interface NotificationCreateDTO {
  /**
   *
   * @type {string}
   * @memberof NotificationCreateDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof NotificationCreateDTO
   */
  body?: string;
}
/**
 *
 * @export
 * @interface NotificationDTO
 */
export interface NotificationDTO {
  /**
   *
   * @type {number}
   * @memberof NotificationDTO
   */
  notificationId?: number;
  /**
   *
   * @type {string}
   * @memberof NotificationDTO
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof NotificationDTO
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof NotificationDTO
   */
  userId?: string;
}
/**
 *
 * @export
 * @interface Page
 */
export interface Page {
  /**
   *
   * @type {number}
   * @memberof Page
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof Page
   */
  totalPages?: number;
  /**
   *
   * @type {number}
   * @memberof Page
   */
  size?: number;
  /**
   *
   * @type {Array<object>}
   * @memberof Page
   */
  content?: Array<object>;
  /**
   *
   * @type {number}
   * @memberof Page
   */
  number?: number;
  /**
   *
   * @type {Array<SortObject>}
   * @memberof Page
   */
  sort?: Array<SortObject>;
  /**
   *
   * @type {boolean}
   * @memberof Page
   */
  first?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof Page
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof Page
   */
  numberOfElements?: number;
  /**
   *
   * @type {PageableObject}
   * @memberof Page
   */
  pageable?: PageableObject;
  /**
   *
   * @type {boolean}
   * @memberof Page
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface PageFacilityDetailsResponseDTO
 */
export interface PageFacilityDetailsResponseDTO {
  /**
   *
   * @type {number}
   * @memberof PageFacilityDetailsResponseDTO
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageFacilityDetailsResponseDTO
   */
  totalPages?: number;
  /**
   *
   * @type {number}
   * @memberof PageFacilityDetailsResponseDTO
   */
  size?: number;
  /**
   *
   * @type {Array<FacilityDetailsResponseDTO>}
   * @memberof PageFacilityDetailsResponseDTO
   */
  content?: Array<FacilityDetailsResponseDTO>;
  /**
   *
   * @type {number}
   * @memberof PageFacilityDetailsResponseDTO
   */
  number?: number;
  /**
   *
   * @type {Array<SortObject>}
   * @memberof PageFacilityDetailsResponseDTO
   */
  sort?: Array<SortObject>;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityDetailsResponseDTO
   */
  first?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityDetailsResponseDTO
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageFacilityDetailsResponseDTO
   */
  numberOfElements?: number;
  /**
   *
   * @type {PageableObject}
   * @memberof PageFacilityDetailsResponseDTO
   */
  pageable?: PageableObject;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityDetailsResponseDTO
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface PageFacilityResponseDTO
 */
export interface PageFacilityResponseDTO {
  /**
   *
   * @type {number}
   * @memberof PageFacilityResponseDTO
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageFacilityResponseDTO
   */
  totalPages?: number;
  /**
   *
   * @type {number}
   * @memberof PageFacilityResponseDTO
   */
  size?: number;
  /**
   *
   * @type {Array<FacilityResponseDTO>}
   * @memberof PageFacilityResponseDTO
   */
  content?: Array<FacilityResponseDTO>;
  /**
   *
   * @type {number}
   * @memberof PageFacilityResponseDTO
   */
  number?: number;
  /**
   *
   * @type {Array<SortObject>}
   * @memberof PageFacilityResponseDTO
   */
  sort?: Array<SortObject>;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityResponseDTO
   */
  first?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityResponseDTO
   */
  last?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageFacilityResponseDTO
   */
  numberOfElements?: number;
  /**
   *
   * @type {PageableObject}
   * @memberof PageFacilityResponseDTO
   */
  pageable?: PageableObject;
  /**
   *
   * @type {boolean}
   * @memberof PageFacilityResponseDTO
   */
  empty?: boolean;
}
/**
 *
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  offset?: number;
  /**
   *
   * @type {Array<SortObject>}
   * @memberof PageableObject
   */
  sort?: Array<SortObject>;
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  paged?: boolean;
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  pageNumber?: number;
  /**
   *
   * @type {number}
   * @memberof PageableObject
   */
  pageSize?: number;
  /**
   *
   * @type {boolean}
   * @memberof PageableObject
   */
  unpaged?: boolean;
}
/**
 *
 * @export
 * @interface ReviewDTO
 */
export interface ReviewDTO {
  /**
   *
   * @type {number}
   * @memberof ReviewDTO
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ReviewDTO
   */
  facilityId?: string;
  /**
   *
   * @type {string}
   * @memberof ReviewDTO
   */
  content?: string;
  /**
   *
   * @type {number}
   * @memberof ReviewDTO
   */
  rating?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ReviewDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof ReviewDTO
   */
  likes?: number;
  /**
   *
   * @type {number}
   * @memberof ReviewDTO
   */
  views?: number;
}
/**
 *
 * @export
 * @interface SortObject
 */
export interface SortObject {
  /**
   *
   * @type {string}
   * @memberof SortObject
   */
  direction?: string;
  /**
   *
   * @type {string}
   * @memberof SortObject
   */
  nullHandling?: string;
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  ascending?: boolean;
  /**
   *
   * @type {string}
   * @memberof SortObject
   */
  property?: string;
  /**
   *
   * @type {boolean}
   * @memberof SortObject
   */
  ignoreCase?: boolean;
}
/**
 *
 * @export
 * @interface TagDTO
 */
export interface TagDTO {
  /**
   *
   * @type {string}
   * @memberof TagDTO
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof TagDTO
   */
  type?: string;
}
/**
 *
 * @export
 * @interface UserChangeInfoDTO
 */
export interface UserChangeInfoDTO {
  /**
   * 변경할 닉네임
   * @type {string}
   * @memberof UserChangeInfoDTO
   */
  nickname?: string;
  /**
   * 변경할 소개글
   * @type {string}
   * @memberof UserChangeInfoDTO
   */
  description?: string;
}
/**
 * 회원가입 요청 데이터
 * @export
 * @interface UserJoinDTO
 */
export interface UserJoinDTO {
  /**
   * 사용자 이메일
   * @type {string}
   * @memberof UserJoinDTO
   */
  email?: string;
  /**
   * 사용자 비밀번호
   * @type {string}
   * @memberof UserJoinDTO
   */
  password?: string;
  /**
   * 비밀번호 확인
   * @type {string}
   * @memberof UserJoinDTO
   */
  checkPassword?: string;
  /**
   * 사용자 닉네임
   * @type {string}
   * @memberof UserJoinDTO
   */
  nickname?: string;
}
/**
 *
 * @export
 * @interface UserLoginDTO
 */
export interface UserLoginDTO {
  /**
   * 사용자 이메일
   * @type {string}
   * @memberof UserLoginDTO
   */
  email?: string;
  /**
   * 사용자 비밀번호
   * @type {string}
   * @memberof UserLoginDTO
   */
  password?: string;
}

/**
 * ActivityControllerApi - axios parameter creator
 * @export
 */
export const ActivityControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createActivity: async (
      activityCreateDTO: ActivityCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityCreateDTO' is not null or undefined
      assertParamExists(
        'createActivity',
        'activityCreateDTO',
        activityCreateDTO
      );
      const localVarPath = `/api/activity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityCreateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteActivity: async (
      activityId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists('deleteActivity', 'activityId', activityId);
      const localVarPath = `/api/activity/{activityId}`.replace(
        `{${'activityId'}}`,
        encodeURIComponent(String(activityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity: async (
      activityId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists('getActivity', 'activityId', activityId);
      const localVarPath = `/api/activity/{activityId}`.replace(
        `{${'activityId'}}`,
        encodeURIComponent(String(activityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} activityId
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateActivity: async (
      activityId: number,
      activityUpdateDTO: ActivityUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityId' is not null or undefined
      assertParamExists('updateActivity', 'activityId', activityId);
      // verify required parameter 'activityUpdateDTO' is not null or undefined
      assertParamExists(
        'updateActivity',
        'activityUpdateDTO',
        activityUpdateDTO
      );
      const localVarPath = `/api/activity/{activityId}`.replace(
        `{${'activityId'}}`,
        encodeURIComponent(String(activityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityUpdateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ActivityControllerApi - functional programming interface
 * @export
 */
export const ActivityControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ActivityControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createActivity(
      activityCreateDTO: ActivityCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActivityResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createActivity(
        activityCreateDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ActivityControllerApi.createActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteActivity(
      activityId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteActivity(
        activityId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ActivityControllerApi.deleteActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActivity(
      activityId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActivityResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActivity(
        activityId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ActivityControllerApi.getActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} activityId
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateActivity(
      activityId: number,
      activityUpdateDTO: ActivityUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActivityResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateActivity(
        activityId,
        activityUpdateDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ActivityControllerApi.updateActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ActivityControllerApi - factory interface
 * @export
 */
export const ActivityControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ActivityControllerApiFp(configuration);
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createActivity(
      activityCreateDTO: ActivityCreateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActivityResponseDTO> {
      return localVarFp
        .createActivity(activityCreateDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteActivity(
      activityId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .deleteActivity(activityId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} activityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivity(
      activityId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActivityResponseDTO> {
      return localVarFp
        .getActivity(activityId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} activityId
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateActivity(
      activityId: number,
      activityUpdateDTO: ActivityUpdateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ActivityResponseDTO> {
      return localVarFp
        .updateActivity(activityId, activityUpdateDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * ActivityControllerApi - object-oriented interface
 * @export
 * @class ActivityControllerApi
 * @extends {BaseAPI}
 */
export class ActivityControllerApi extends BaseAPI {
  /**
   *
   * @param {ActivityCreateDTO} activityCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityControllerApi
   */
  public createActivity(
    activityCreateDTO: ActivityCreateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return ActivityControllerApiFp(this.configuration)
      .createActivity(activityCreateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} activityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityControllerApi
   */
  public deleteActivity(activityId: number, options?: RawAxiosRequestConfig) {
    return ActivityControllerApiFp(this.configuration)
      .deleteActivity(activityId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} activityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityControllerApi
   */
  public getActivity(activityId: number, options?: RawAxiosRequestConfig) {
    return ActivityControllerApiFp(this.configuration)
      .getActivity(activityId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} activityId
   * @param {ActivityUpdateDTO} activityUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivityControllerApi
   */
  public updateActivity(
    activityId: number,
    activityUpdateDTO: ActivityUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return ActivityControllerApiFp(this.configuration)
      .updateActivity(activityId, activityUpdateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * CalendarControllerApi - axios parameter creator
 * @export
 */
export const CalendarControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCalendar: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calendar/{summary}`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCalendars: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calendars`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * CalendarControllerApi - functional programming interface
 * @export
 */
export const CalendarControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    CalendarControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCalendar(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createCalendar(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CalendarControllerApi.createCalendar']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listCalendars(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listCalendars(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CalendarControllerApi.listCalendars']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * CalendarControllerApi - factory interface
 * @export
 */
export const CalendarControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CalendarControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCalendar(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .createCalendar(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCalendars(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .listCalendars(options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * CalendarControllerApi - object-oriented interface
 * @export
 * @class CalendarControllerApi
 * @extends {BaseAPI}
 */
export class CalendarControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarControllerApi
   */
  public createCalendar(options?: RawAxiosRequestConfig) {
    return CalendarControllerApiFp(this.configuration)
      .createCalendar(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarControllerApi
   */
  public listCalendars(options?: RawAxiosRequestConfig) {
    return CalendarControllerApiFp(this.configuration)
      .listCalendars(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EmailControllerApi - axios parameter creator
 * @export
 */
export const EmailControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * 이메일 인증을 위한 코드를 발송합니다
     * @summary 이메일 발송
     * @param {string} email 인증번호를 보낼 email 주소
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCode: async (
      email: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('sendCode', 'email', email);
      const localVarPath = `/api/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
     * @summary 검증
     * @param {string} email 인증번호를 보낸 email 주소
     * @param {string} code 받은 인증번호
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCode: async (
      email: string,
      code: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('verifyCode', 'email', email);
      // verify required parameter 'code' is not null or undefined
      assertParamExists('verifyCode', 'code', code);
      const localVarPath = `/api/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (email !== undefined) {
        localVarQueryParameter['email'] = email;
      }

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export const EmailControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EmailControllerApiAxiosParamCreator(configuration);
  return {
    /**
     * 이메일 인증을 위한 코드를 발송합니다
     * @summary 이메일 발송
     * @param {string} email 인증번호를 보낼 email 주소
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendCode(
      email: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendCode(
        email,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EmailControllerApi.sendCode']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
     * @summary 검증
     * @param {string} email 인증번호를 보낸 email 주소
     * @param {string} code 받은 인증번호
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyCode(
      email: string,
      code: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCode(
        email,
        code,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EmailControllerApi.verifyCode']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EmailControllerApi - factory interface
 * @export
 */
export const EmailControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EmailControllerApiFp(configuration);
  return {
    /**
     * 이메일 인증을 위한 코드를 발송합니다
     * @summary 이메일 발송
     * @param {string} email 인증번호를 보낼 email 주소
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendCode(
      email: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .sendCode(email, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
     * @summary 검증
     * @param {string} email 인증번호를 보낸 email 주소
     * @param {string} code 받은 인증번호
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCode(
      email: string,
      code: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .verifyCode(email, code, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export class EmailControllerApi extends BaseAPI {
  /**
   * 이메일 인증을 위한 코드를 발송합니다
   * @summary 이메일 발송
   * @param {string} email 인증번호를 보낼 email 주소
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailControllerApi
   */
  public sendCode(email: string, options?: RawAxiosRequestConfig) {
    return EmailControllerApiFp(this.configuration)
      .sendCode(email, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 보낸 코드값이 서버의 저장값과 일치하는지 확인합니다
   * @summary 검증
   * @param {string} email 인증번호를 보낸 email 주소
   * @param {string} code 받은 인증번호
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailControllerApi
   */
  public verifyCode(
    email: string,
    code: string,
    options?: RawAxiosRequestConfig
  ) {
    return EmailControllerApiFp(this.configuration)
      .verifyCode(email, code, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * EventControllerApi - axios parameter creator
 * @export
 */
export const EventControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEvent: async (
      activityCreateDTO: ActivityCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityCreateDTO' is not null or undefined
      assertParamExists('createEvent', 'activityCreateDTO', activityCreateDTO);
      const localVarPath = `/api/google-calendar/event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityCreateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEvent: async (
      body: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('deleteEvent', 'body', body);
      const localVarPath = `/api/google-calendar/event/eventId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/google-calendar/event/events`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent: async (
      activityUpdateDTO: ActivityUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'activityUpdateDTO' is not null or undefined
      assertParamExists('updateEvent', 'activityUpdateDTO', activityUpdateDTO);
      const localVarPath = `/api/google-calendar/event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        activityUpdateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * EventControllerApi - functional programming interface
 * @export
 */
export const EventControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EventControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEvent(
      activityCreateDTO: ActivityCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(
        activityCreateDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventControllerApi.createEvent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEvent(
      body: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventControllerApi.deleteEvent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listEvents(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listEvents(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventControllerApi.listEvents']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEvent(
      activityUpdateDTO: ActivityUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvent(
        activityUpdateDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['EventControllerApi.updateEvent']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * EventControllerApi - factory interface
 * @export
 */
export const EventControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EventControllerApiFp(configuration);
  return {
    /**
     *
     * @param {ActivityCreateDTO} activityCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEvent(
      activityCreateDTO: ActivityCreateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .createEvent(activityCreateDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEvent(
      body: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .deleteEvent(body, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listEvents(options?: RawAxiosRequestConfig): AxiosPromise<Events> {
      return localVarFp
        .listEvents(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ActivityUpdateDTO} activityUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEvent(
      activityUpdateDTO: ActivityUpdateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .updateEvent(activityUpdateDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * EventControllerApi - object-oriented interface
 * @export
 * @class EventControllerApi
 * @extends {BaseAPI}
 */
export class EventControllerApi extends BaseAPI {
  /**
   *
   * @param {ActivityCreateDTO} activityCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventControllerApi
   */
  public createEvent(
    activityCreateDTO: ActivityCreateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return EventControllerApiFp(this.configuration)
      .createEvent(activityCreateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventControllerApi
   */
  public deleteEvent(body: string, options?: RawAxiosRequestConfig) {
    return EventControllerApiFp(this.configuration)
      .deleteEvent(body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventControllerApi
   */
  public listEvents(options?: RawAxiosRequestConfig) {
    return EventControllerApiFp(this.configuration)
      .listEvents(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ActivityUpdateDTO} activityUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventControllerApi
   */
  public updateEvent(
    activityUpdateDTO: ActivityUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return EventControllerApiFp(this.configuration)
      .updateEvent(activityUpdateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FacilityControllerApi - axios parameter creator
 * @export
 */
export const FacilityControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
     * @summary 모든 시설 상세 정보 저장
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAllFacilityDetails: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/facility-detail/all-memory`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAll: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/facility-detail/all`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 시설 상세 정보를 삭제합니다.
     * @summary 시설 상세 정보 삭제
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFacilityDetail: async (
      facilityId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityId' is not null or undefined
      assertParamExists('deleteFacilityDetail', 'facilityId', facilityId);
      const localVarPath = `/api/facility-detail/{facilityId}`.replace(
        `{${'facilityId'}}`,
        encodeURIComponent(String(facilityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
     * @summary 시설 필터링 검색
     * @param {FacilityFilterDTO} facilityFilterDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    facilityFilter: async (
      facilityFilterDTO: FacilityFilterDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityFilterDTO' is not null or undefined
      assertParamExists(
        'facilityFilter',
        'facilityFilterDTO',
        facilityFilterDTO
      );
      const localVarPath = `/api/facility-detail/filter`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        facilityFilterDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 모든 시설 목록을 페이지 단위로 조회합니다.
     * @summary 시설 목록 페이지 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFacilities: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/facility-detail/list`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
     * @summary 시설 상세 정보 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFacilityDetails: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/facility-detail/details`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 시설의 이름으로 상세 정보를 가져옵니다.
     * @summary 시설 상세 정보 가져오기
     * @param {string} facilityName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFacilityDetail: async (
      facilityName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityName' is not null or undefined
      assertParamExists('getFacilityDetail', 'facilityName', facilityName);
      const localVarPath = `/api/facility-detail`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (facilityName !== undefined) {
        localVarQueryParameter['facilityName'] = facilityName;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 시설 ID로 상세 정보를 조회합니다.
     * @summary 시설 상세 정보 페이지 조회
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readFacilityDetails: async (
      facilityId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityId' is not null or undefined
      assertParamExists('readFacilityDetails', 'facilityId', facilityId);
      const localVarPath = `/api/facility-detail/{facilityId}`.replace(
        `{${'facilityId'}}`,
        encodeURIComponent(String(facilityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
     * @summary 위치기반 시설 검색
     * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByLocation: async (
      facilityLocationDTO: FacilityLocationDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityLocationDTO' is not null or undefined
      assertParamExists(
        'searchByLocation',
        'facilityLocationDTO',
        facilityLocationDTO
      );
      const localVarPath = `/api/facility-detail/location`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        facilityLocationDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 시설 상세 정보를 업데이트합니다.
     * @summary 시설 상세 정보 업데이트
     * @param {string} facilityId
     * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFacilityDetail: async (
      facilityId: string,
      facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'facilityId' is not null or undefined
      assertParamExists('updateFacilityDetail', 'facilityId', facilityId);
      // verify required parameter 'facilityDetailsUpdateDTO' is not null or undefined
      assertParamExists(
        'updateFacilityDetail',
        'facilityDetailsUpdateDTO',
        facilityDetailsUpdateDTO
      );
      const localVarPath = `/api/facility-detail/{facilityId}`.replace(
        `{${'facilityId'}}`,
        encodeURIComponent(String(facilityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        facilityDetailsUpdateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * FacilityControllerApi - functional programming interface
 * @export
 */
export const FacilityControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    FacilityControllerApiAxiosParamCreator(configuration);
  return {
    /**
     * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
     * @summary 모든 시설 상세 정보 저장
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addAllFacilityDetails(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addAllFacilityDetails(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.addAllFacilityDetails']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAll(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteAll(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.deleteAll']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 시설 상세 정보를 삭제합니다.
     * @summary 시설 상세 정보 삭제
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFacilityDetail(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFacilityDetail(
          facilityId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.deleteFacilityDetail']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
     * @summary 시설 필터링 검색
     * @param {FacilityFilterDTO} facilityFilterDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async facilityFilter(
      facilityFilterDTO: FacilityFilterDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageFacilityResponseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.facilityFilter(
        facilityFilterDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.facilityFilter']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 모든 시설 목록을 페이지 단위로 조회합니다.
     * @summary 시설 목록 페이지 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllFacilities(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllFacilities(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.getAllFacilities']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
     * @summary 시설 상세 정보 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllFacilityDetails(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PageFacilityDetailsResponseDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllFacilityDetails(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.getAllFacilityDetails']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 시설의 이름으로 상세 정보를 가져옵니다.
     * @summary 시설 상세 정보 가져오기
     * @param {string} facilityName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFacilityDetail(
      facilityName: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFacilityDetail(
          facilityName,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.getFacilityDetail']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 시설 ID로 상세 정보를 조회합니다.
     * @summary 시설 상세 정보 페이지 조회
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readFacilityDetails(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FacilityDetailsResponseDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readFacilityDetails(
          facilityId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.readFacilityDetails']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
     * @summary 위치기반 시설 검색
     * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchByLocation(
      facilityLocationDTO: FacilityLocationDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchByLocation(
          facilityLocationDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.searchByLocation']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 시설 상세 정보를 업데이트합니다.
     * @summary 시설 상세 정보 업데이트
     * @param {string} facilityId
     * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFacilityDetail(
      facilityId: string,
      facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FacilityDetailsResponseDTO>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFacilityDetail(
          facilityId,
          facilityDetailsUpdateDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FacilityControllerApi.updateFacilityDetail']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * FacilityControllerApi - factory interface
 * @export
 */
export const FacilityControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FacilityControllerApiFp(configuration);
  return {
    /**
     * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
     * @summary 모든 시설 상세 정보 저장
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAllFacilityDetails(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .addAllFacilityDetails(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAll(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .deleteAll(options)
        .then(request => request(axios, basePath));
    },
    /**
     * 시설 상세 정보를 삭제합니다.
     * @summary 시설 상세 정보 삭제
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFacilityDetail(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: string }> {
      return localVarFp
        .deleteFacilityDetail(facilityId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
     * @summary 시설 필터링 검색
     * @param {FacilityFilterDTO} facilityFilterDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    facilityFilter(
      facilityFilterDTO: FacilityFilterDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageFacilityResponseDTO> {
      return localVarFp
        .facilityFilter(facilityFilterDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 모든 시설 목록을 페이지 단위로 조회합니다.
     * @summary 시설 목록 페이지 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFacilities(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .getAllFacilities(options)
        .then(request => request(axios, basePath));
    },
    /**
     * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
     * @summary 시설 상세 정보 목록 조회
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllFacilityDetails(
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PageFacilityDetailsResponseDTO> {
      return localVarFp
        .getAllFacilityDetails(options)
        .then(request => request(axios, basePath));
    },
    /**
     * 시설의 이름으로 상세 정보를 가져옵니다.
     * @summary 시설 상세 정보 가져오기
     * @param {string} facilityName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFacilityDetail(
      facilityName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .getFacilityDetail(facilityName, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 시설 ID로 상세 정보를 조회합니다.
     * @summary 시설 상세 정보 페이지 조회
     * @param {string} facilityId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readFacilityDetails(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<FacilityDetailsResponseDTO> {
      return localVarFp
        .readFacilityDetails(facilityId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
     * @summary 위치기반 시설 검색
     * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchByLocation(
      facilityLocationDTO: FacilityLocationDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Page> {
      return localVarFp
        .searchByLocation(facilityLocationDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 시설 상세 정보를 업데이트합니다.
     * @summary 시설 상세 정보 업데이트
     * @param {string} facilityId
     * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFacilityDetail(
      facilityId: string,
      facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<FacilityDetailsResponseDTO> {
      return localVarFp
        .updateFacilityDetail(facilityId, facilityDetailsUpdateDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * FacilityControllerApi - object-oriented interface
 * @export
 * @class FacilityControllerApi
 * @extends {BaseAPI}
 */
export class FacilityControllerApi extends BaseAPI {
  /**
   * 서울시 공공 서비스예약의 모든 시설 데이터를 API를 통해 가져와서 저장합니다.
   * @summary 모든 시설 상세 정보 저장
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public addAllFacilityDetails(options?: RawAxiosRequestConfig) {
    return FacilityControllerApiFp(this.configuration)
      .addAllFacilityDetails(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public deleteAll(options?: RawAxiosRequestConfig) {
    return FacilityControllerApiFp(this.configuration)
      .deleteAll(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 시설 상세 정보를 삭제합니다.
   * @summary 시설 상세 정보 삭제
   * @param {string} facilityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public deleteFacilityDetail(
    facilityId: string,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .deleteFacilityDetail(facilityId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 시설 검색정보를 여러 조건으로 필터링하여 조회합니다.
   * @summary 시설 필터링 검색
   * @param {FacilityFilterDTO} facilityFilterDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public facilityFilter(
    facilityFilterDTO: FacilityFilterDTO,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .facilityFilter(facilityFilterDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 모든 시설 목록을 페이지 단위로 조회합니다.
   * @summary 시설 목록 페이지 조회
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public getAllFacilities(options?: RawAxiosRequestConfig) {
    return FacilityControllerApiFp(this.configuration)
      .getAllFacilities(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 모든 시설 상세 정보를 페이지 단위로 조회합니다.
   * @summary 시설 상세 정보 목록 조회
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public getAllFacilityDetails(options?: RawAxiosRequestConfig) {
    return FacilityControllerApiFp(this.configuration)
      .getAllFacilityDetails(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 시설의 이름으로 상세 정보를 가져옵니다.
   * @summary 시설 상세 정보 가져오기
   * @param {string} facilityName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public getFacilityDetail(
    facilityName: string,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .getFacilityDetail(facilityName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 시설 ID로 상세 정보를 조회합니다.
   * @summary 시설 상세 정보 페이지 조회
   * @param {string} facilityId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public readFacilityDetails(
    facilityId: string,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .readFacilityDetails(facilityId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 주어진 위도, 경도, 반경에 해당하는 시설들을 검색합니다.
   * @summary 위치기반 시설 검색
   * @param {FacilityLocationDTO} facilityLocationDTO 위치 정보와 반경을 포함한 검색 요청 데이터
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public searchByLocation(
    facilityLocationDTO: FacilityLocationDTO,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .searchByLocation(facilityLocationDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 시설 상세 정보를 업데이트합니다.
   * @summary 시설 상세 정보 업데이트
   * @param {string} facilityId
   * @param {FacilityDetailsUpdateDTO} facilityDetailsUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FacilityControllerApi
   */
  public updateFacilityDetail(
    facilityId: string,
    facilityDetailsUpdateDTO: FacilityDetailsUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return FacilityControllerApiFp(this.configuration)
      .updateFacilityDetail(facilityId, facilityDetailsUpdateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * FcmControllerApi - axios parameter creator
 * @export
 */
export const FcmControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFcmToken: async (
      userLoginDTO: UserLoginDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userLoginDTO' is not null or undefined
      assertParamExists('handleFcmToken', 'userLoginDTO', userLoginDTO);
      const localVarPath = `/api/fcm`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * FcmControllerApi - functional programming interface
 * @export
 */
export const FcmControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FcmControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async handleFcmToken(
      userLoginDTO: UserLoginDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.handleFcmToken(
        userLoginDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FcmControllerApi.handleFcmToken']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * FcmControllerApi - factory interface
 * @export
 */
export const FcmControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FcmControllerApiFp(configuration);
  return {
    /**
     *
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFcmToken(
      userLoginDTO: UserLoginDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .handleFcmToken(userLoginDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * FcmControllerApi - object-oriented interface
 * @export
 * @class FcmControllerApi
 * @extends {BaseAPI}
 */
export class FcmControllerApi extends BaseAPI {
  /**
   *
   * @param {UserLoginDTO} userLoginDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FcmControllerApi
   */
  public handleFcmToken(
    userLoginDTO: UserLoginDTO,
    options?: RawAxiosRequestConfig
  ) {
    return FcmControllerApiFp(this.configuration)
      .handleFcmToken(userLoginDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * MeetingBoardControllerApi - axios parameter creator
 * @export
 */
export const MeetingBoardControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMeetingBoard: async (
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
      assertParamExists(
        'createMeetingBoard',
        'meetingBoardRequestDTO',
        meetingBoardRequestDTO
      );
      const localVarPath = `/api/meetingboard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        meetingBoardRequestDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMeetingBoard: async (
      mbId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mbId' is not null or undefined
      assertParamExists('deleteMeetingBoard', 'mbId', mbId);
      const localVarPath = `/api/meetingboard/{mbId}`.replace(
        `{${'mbId'}}`,
        encodeURIComponent(String(mbId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMeetingBoards: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/meetingboard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingBoardById: async (
      mbId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mbId' is not null or undefined
      assertParamExists('getMeetingBoardById', 'mbId', mbId);
      const localVarPath = `/api/meetingboard/{mbId}`.replace(
        `{${'mbId'}}`,
        encodeURIComponent(String(mbId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} mbId
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMeetingBoard: async (
      mbId: number,
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'mbId' is not null or undefined
      assertParamExists('updateMeetingBoard', 'mbId', mbId);
      // verify required parameter 'meetingBoardRequestDTO' is not null or undefined
      assertParamExists(
        'updateMeetingBoard',
        'meetingBoardRequestDTO',
        meetingBoardRequestDTO
      );
      const localVarPath = `/api/meetingboard/{mbId}`.replace(
        `{${'mbId'}}`,
        encodeURIComponent(String(mbId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        meetingBoardRequestDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * MeetingBoardControllerApi - functional programming interface
 * @export
 */
export const MeetingBoardControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    MeetingBoardControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMeetingBoard(
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createMeetingBoard(
          meetingBoardRequestDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['MeetingBoardControllerApi.createMeetingBoard']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMeetingBoard(
      mbId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteMeetingBoard(mbId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['MeetingBoardControllerApi.deleteMeetingBoard']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllMeetingBoards(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllMeetingBoards(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['MeetingBoardControllerApi.getAllMeetingBoards']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMeetingBoardById(
      mbId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMeetingBoardById(mbId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['MeetingBoardControllerApi.getMeetingBoardById']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} mbId
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMeetingBoard(
      mbId: number,
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateMeetingBoard(
          mbId,
          meetingBoardRequestDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['MeetingBoardControllerApi.updateMeetingBoard']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * MeetingBoardControllerApi - factory interface
 * @export
 */
export const MeetingBoardControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MeetingBoardControllerApiFp(configuration);
  return {
    /**
     *
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMeetingBoard(
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .createMeetingBoard(meetingBoardRequestDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMeetingBoard(
      mbId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .deleteMeetingBoard(mbId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMeetingBoards(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .getAllMeetingBoards(options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} mbId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMeetingBoardById(
      mbId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .getMeetingBoardById(mbId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} mbId
     * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMeetingBoard(
      mbId: number,
      meetingBoardRequestDTO: MeetingBoardRequestDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .updateMeetingBoard(mbId, meetingBoardRequestDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * MeetingBoardControllerApi - object-oriented interface
 * @export
 * @class MeetingBoardControllerApi
 * @extends {BaseAPI}
 */
export class MeetingBoardControllerApi extends BaseAPI {
  /**
   *
   * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingBoardControllerApi
   */
  public createMeetingBoard(
    meetingBoardRequestDTO: MeetingBoardRequestDTO,
    options?: RawAxiosRequestConfig
  ) {
    return MeetingBoardControllerApiFp(this.configuration)
      .createMeetingBoard(meetingBoardRequestDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} mbId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingBoardControllerApi
   */
  public deleteMeetingBoard(mbId: number, options?: RawAxiosRequestConfig) {
    return MeetingBoardControllerApiFp(this.configuration)
      .deleteMeetingBoard(mbId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingBoardControllerApi
   */
  public getAllMeetingBoards(options?: RawAxiosRequestConfig) {
    return MeetingBoardControllerApiFp(this.configuration)
      .getAllMeetingBoards(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} mbId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingBoardControllerApi
   */
  public getMeetingBoardById(mbId: number, options?: RawAxiosRequestConfig) {
    return MeetingBoardControllerApiFp(this.configuration)
      .getMeetingBoardById(mbId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} mbId
   * @param {MeetingBoardRequestDTO} meetingBoardRequestDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MeetingBoardControllerApi
   */
  public updateMeetingBoard(
    mbId: number,
    meetingBoardRequestDTO: MeetingBoardRequestDTO,
    options?: RawAxiosRequestConfig
  ) {
    return MeetingBoardControllerApiFp(this.configuration)
      .updateMeetingBoard(mbId, meetingBoardRequestDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * NotificationControllerApi - axios parameter creator
 * @export
 */
export const NotificationControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPushNotification1: async (
      notificationDTO: NotificationDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notificationDTO' is not null or undefined
      assertParamExists(
        'sendPushNotification1',
        'notificationDTO',
        notificationDTO
      );
      const localVarPath = `/api/notification/send`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        notificationDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * NotificationControllerApi - functional programming interface
 * @export
 */
export const NotificationControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    NotificationControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendPushNotification1(
      notificationDTO: NotificationDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendPushNotification1(
          notificationDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['NotificationControllerApi.sendPushNotification1']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * NotificationControllerApi - factory interface
 * @export
 */
export const NotificationControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = NotificationControllerApiFp(configuration);
  return {
    /**
     *
     * @param {NotificationDTO} notificationDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPushNotification1(
      notificationDTO: NotificationDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .sendPushNotification1(notificationDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * NotificationControllerApi - object-oriented interface
 * @export
 * @class NotificationControllerApi
 * @extends {BaseAPI}
 */
export class NotificationControllerApi extends BaseAPI {
  /**
   *
   * @param {NotificationDTO} notificationDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationControllerApi
   */
  public sendPushNotification1(
    notificationDTO: NotificationDTO,
    options?: RawAxiosRequestConfig
  ) {
    return NotificationControllerApiFp(this.configuration)
      .sendPushNotification1(notificationDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * OAuth2ControllerApi - axios parameter creator
 * @export
 */
export const OAuth2ControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * OAUTH2.0을 통해 로그인합니다
     * @summary 소셜 로그인
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthLogin: async (
      provider: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('oauthLogin', 'provider', provider);
      const localVarPath = `/api/oauth2/{provider}`.replace(
        `{${'provider'}}`,
        encodeURIComponent(String(provider))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * OAuth2ControllerApi - functional programming interface
 * @export
 */
export const OAuth2ControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    OAuth2ControllerApiAxiosParamCreator(configuration);
  return {
    /**
     * OAUTH2.0을 통해 로그인합니다
     * @summary 소셜 로그인
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthLogin(
      provider: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauthLogin(
        provider,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2ControllerApi.oauthLogin']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * OAuth2ControllerApi - factory interface
 * @export
 */
export const OAuth2ControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OAuth2ControllerApiFp(configuration);
  return {
    /**
     * OAUTH2.0을 통해 로그인합니다
     * @summary 소셜 로그인
     * @param {string} provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthLogin(
      provider: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .oauthLogin(provider, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * OAuth2ControllerApi - object-oriented interface
 * @export
 * @class OAuth2ControllerApi
 * @extends {BaseAPI}
 */
export class OAuth2ControllerApi extends BaseAPI {
  /**
   * OAUTH2.0을 통해 로그인합니다
   * @summary 소셜 로그인
   * @param {string} provider
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OAuth2ControllerApi
   */
  public oauthLogin(provider: string, options?: RawAxiosRequestConfig) {
    return OAuth2ControllerApiFp(this.configuration)
      .oauthLogin(provider, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * PushNotificationControllerApi - axios parameter creator
 * @export
 */
export const PushNotificationControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {NotificationCreateDTO} notificationCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPushNotification: async (
      notificationCreateDTO: NotificationCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notificationCreateDTO' is not null or undefined
      assertParamExists(
        'sendPushNotification',
        'notificationCreateDTO',
        notificationCreateDTO
      );
      const localVarPath = `/api/push/send`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        notificationCreateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * PushNotificationControllerApi - functional programming interface
 * @export
 */
export const PushNotificationControllerApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    PushNotificationControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {NotificationCreateDTO} notificationCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendPushNotification(
      notificationCreateDTO: NotificationCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.sendPushNotification(
          notificationCreateDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'PushNotificationControllerApi.sendPushNotification'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * PushNotificationControllerApi - factory interface
 * @export
 */
export const PushNotificationControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PushNotificationControllerApiFp(configuration);
  return {
    /**
     *
     * @param {NotificationCreateDTO} notificationCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendPushNotification(
      notificationCreateDTO: NotificationCreateDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .sendPushNotification(notificationCreateDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * PushNotificationControllerApi - object-oriented interface
 * @export
 * @class PushNotificationControllerApi
 * @extends {BaseAPI}
 */
export class PushNotificationControllerApi extends BaseAPI {
  /**
   *
   * @param {NotificationCreateDTO} notificationCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PushNotificationControllerApi
   */
  public sendPushNotification(
    notificationCreateDTO: NotificationCreateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PushNotificationControllerApiFp(this.configuration)
      .sendPushNotification(notificationCreateDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * ReviewControllerApi - axios parameter creator
 * @export
 */
export const ReviewControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview: async (
      facilityId: string,
      reviewDTO: ReviewDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewDTO' is not null or undefined
      assertParamExists('createReview', 'reviewDTO', reviewDTO);
      const localVarPath = `/api/facility-details/{facilityId}/reviews`.replace(
        `{${'facilityId'}}`,
        encodeURIComponent(String(facilityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviewDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview: async (
      facilityId: string,
      reviewId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('deleteReview', 'reviewId', reviewId);
      const localVarPath =
        `/api/facility-details/{facilityId}/reviews/{reviewId}`
          .replace(`{${'facilityId'}}`, encodeURIComponent(String(facilityId)))
          .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReviewsByFacility: async (
      facilityId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/facility-details/{facilityId}/reviews`.replace(
        `{${'facilityId'}}`,
        encodeURIComponent(String(facilityId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     *
     * @param {number} reviewId
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReview: async (
      facilityId: string,
      reviewId: number,
      reviewDTO: ReviewDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('updateReview', 'reviewId', reviewId);
      // verify required parameter 'reviewDTO' is not null or undefined
      assertParamExists('updateReview', 'reviewDTO', reviewDTO);
      const localVarPath =
        `/api/facility-details/{facilityId}/reviews/{reviewId}`
          .replace(`{${'facilityId'}}`, encodeURIComponent(String(facilityId)))
          .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        reviewDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ReviewControllerApi - functional programming interface
 * @export
 */
export const ReviewControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ReviewControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReview(
      reviewDTO: ReviewDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(
        reviewDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewControllerApi.createReview']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteReview(
      facilityId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(
        facilityId,
        reviewId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewControllerApi.deleteReview']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getReviewsByFacility(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: object }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getReviewsByFacility(
          facilityId,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewControllerApi.getReviewsByFacility']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} reviewId
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateReview(
      reviewId: number,
      reviewDTO: ReviewDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReviewDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(
        reviewId,
        reviewDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewControllerApi.updateReview']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * ReviewControllerApi - factory interface
 * @export
 */
export const ReviewControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ReviewControllerApiFp(configuration);
  return {
    /**
     *
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview(
      reviewDTO: ReviewDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ReviewDTO> {
      return localVarFp
        .createReview(reviewDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview(
      facilityId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<object> {
      return localVarFp
        .deleteReview(facilityId, reviewId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReviewsByFacility(
      facilityId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<{ [key: string]: object }> {
      return localVarFp
        .getReviewsByFacility(facilityId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} reviewId
     * @param {ReviewDTO} reviewDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReview(
      reviewId: number,
      reviewDTO: ReviewDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ReviewDTO> {
      return localVarFp
        .updateReview(reviewId, reviewDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * ReviewControllerApi - object-oriented interface
 * @export
 * @class ReviewControllerApi
 * @extends {BaseAPI}
 */
export class ReviewControllerApi extends BaseAPI {
  /**
   *
   * @param {ReviewDTO} reviewDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewControllerApi
   */
  public createReview(
    facilityId: string,
    reviewDTO: ReviewDTO,
    options?: RawAxiosRequestConfig
  ) {
    return ReviewControllerApiFp(this.configuration)
      .createReview(facilityId, reviewDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} reviewId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewControllerApi
   */
  public deleteReview(
    facilityId: string,
    reviewId: number,
    options?: RawAxiosRequestConfig
  ) {
    return ReviewControllerApiFp(this.configuration)
      .deleteReview(facilityId, reviewId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewControllerApi
   */
  public getReviewsByFacility(
    facilityId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ReviewControllerApiFp(this.configuration)
      .getReviewsByFacility(facilityId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} reviewId
   * @param {ReviewDTO} reviewDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewControllerApi
   */
  public updateReview(
    facilityId: string,
    reviewId: number,
    reviewDTO: ReviewDTO,
    options?: RawAxiosRequestConfig
  ) {
    return ReviewControllerApiFp(this.configuration)
      .updateReview(facilityId, reviewId, reviewDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTags: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/tags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    TagControllerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTags(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getTags(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['TagControllerApi.getTags']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TagControllerApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTags(options?: RawAxiosRequestConfig): AxiosPromise<Array<TagDTO>> {
      return localVarFp
        .getTags(options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TagControllerApi
   */
  public getTags(options?: RawAxiosRequestConfig) {
    return TagControllerApiFp(this.configuration)
      .getTags(options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * UserId를 이용해 비밀번호를 변경합니다
     * @summary 비밀번호 변경
     * @param {string} userId
     * @param {ChangePasswordDTO} changePasswordDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      userId: string,
      changePasswordDTO: ChangePasswordDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('changePassword', 'userId', userId);
      // verify required parameter 'changePasswordDTO' is not null or undefined
      assertParamExists(
        'changePassword',
        'changePasswordDTO',
        changePasswordDTO
      );
      const localVarPath = `/api/user/password/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePasswordDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * UserId를 이용해 프로필 사진을 변경합니다
     * @summary 프로필 사진 변경
     * @param {string} userId
     * @param {File} [multipartFile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeProfile: async (
      userId: string,
      multipartFile?: File,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('changeProfile', 'userId', userId);
      const localVarPath = `/api/user/profile/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (multipartFile !== undefined) {
        localVarFormParams.append('multipartFile', multipartFile as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * UserId를 이용해 회원정보를 삭제합니다
     * @summary 회원 탈퇴
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteUser', 'userId', userId);
      const localVarPath = `/api/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * UserId를 이용해 회원정보를 조회합니다
     * @summary 회원 정보 조회
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findMyInformation: async (
      userId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('findMyInformation', 'userId', userId);
      const localVarPath = `/api/user/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
     * @summary 회원가입
     * @param {UserJoinDTO} userJoinDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    join: async (
      userJoinDTO: UserJoinDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userJoinDTO' is not null or undefined
      assertParamExists('join', 'userJoinDTO', userJoinDTO);
      const localVarPath = `/api/user/join`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userJoinDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 이메일, 암호를 입력하여 로그인합니다
     * @summary 로그인
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      userLoginDTO: UserLoginDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userLoginDTO' is not null or undefined
      assertParamExists('login', 'userLoginDTO', userLoginDTO);
      const localVarPath = `/api/user/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLoginDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 로그아웃을 합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/user/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resignAccessTokenByCookie: async (
      refreshToken: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'refreshToken' is not null or undefined
      assertParamExists(
        'resignAccessTokenByCookie',
        'refreshToken',
        refreshToken
      );
      const localVarPath = `/api/user/refresh/cookie`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resignAccessTokenByHeader: async (
      authorization: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        'resignAccessTokenByHeader',
        'authorization',
        authorization
      );
      const localVarPath = `/api/user/refresh/header`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (authorization != null) {
        localVarHeaderParameter['Authorization'] = String(authorization);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * UserId를 이용해 소개글을 변경합니다
     * @summary 소개글 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDescription: async (
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('updateDescription', 'userId', userId);
      // verify required parameter 'userChangeInfoDTO' is not null or undefined
      assertParamExists(
        'updateDescription',
        'userChangeInfoDTO',
        userChangeInfoDTO
      );
      const localVarPath = `/api/user/description/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userChangeInfoDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
     * @summary 닉네임 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNickname: async (
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('updateNickname', 'userId', userId);
      // verify required parameter 'userChangeInfoDTO' is not null or undefined
      assertParamExists(
        'updateNickname',
        'userChangeInfoDTO',
        userChangeInfoDTO
      );
      const localVarPath = `/api/user/nickname/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication Bearer Authentication required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userChangeInfoDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserControllerApiAxiosParamCreator(configuration);
  return {
    /**
     * UserId를 이용해 비밀번호를 변경합니다
     * @summary 비밀번호 변경
     * @param {string} userId
     * @param {ChangePasswordDTO} changePasswordDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      userId: string,
      changePasswordDTO: ChangePasswordDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
        userId,
        changePasswordDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.changePassword']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * UserId를 이용해 프로필 사진을 변경합니다
     * @summary 프로필 사진 변경
     * @param {string} userId
     * @param {File} [multipartFile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeProfile(
      userId: string,
      multipartFile?: File,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeProfile(
        userId,
        multipartFile,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.changeProfile']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * UserId를 이용해 회원정보를 삭제합니다
     * @summary 회원 탈퇴
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.deleteUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * UserId를 이용해 회원정보를 조회합니다
     * @summary 회원 정보 조회
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async findMyInformation(
      userId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.findMyInformation(userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.findMyInformation']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
     * @summary 회원가입
     * @param {UserJoinDTO} userJoinDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async join(
      userJoinDTO: UserJoinDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.join(
        userJoinDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.join']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 이메일, 암호를 입력하여 로그인합니다
     * @summary 로그인
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      userLoginDTO: UserLoginDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        userLoginDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.login']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 로그아웃을 합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.logout']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resignAccessTokenByCookie(
      refreshToken: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resignAccessTokenByCookie(
          refreshToken,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.resignAccessTokenByCookie']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resignAccessTokenByHeader(
      authorization: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resignAccessTokenByHeader(
          authorization,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.resignAccessTokenByHeader']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * UserId를 이용해 소개글을 변경합니다
     * @summary 소개글 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateDescription(
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateDescription(
          userId,
          userChangeInfoDTO,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.updateDescription']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
     * @summary 닉네임 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateNickname(
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateNickname(
        userId,
        userChangeInfoDTO,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserControllerApi.updateNickname']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    }
  };
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserControllerApiFp(configuration);
  return {
    /**
     * UserId를 이용해 비밀번호를 변경합니다
     * @summary 비밀번호 변경
     * @param {string} userId
     * @param {ChangePasswordDTO} changePasswordDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      userId: string,
      changePasswordDTO: ChangePasswordDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .changePassword(userId, changePasswordDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * UserId를 이용해 프로필 사진을 변경합니다
     * @summary 프로필 사진 변경
     * @param {string} userId
     * @param {File} [multipartFile]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeProfile(
      userId: string,
      multipartFile?: File,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .changeProfile(userId, multipartFile, options)
        .then(request => request(axios, basePath));
    },
    /**
     * UserId를 이용해 회원정보를 삭제합니다
     * @summary 회원 탈퇴
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUser(userId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * UserId를 이용해 회원정보를 조회합니다
     * @summary 회원 정보 조회
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findMyInformation(
      userId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .findMyInformation(userId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
     * @summary 회원가입
     * @param {UserJoinDTO} userJoinDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    join(
      userJoinDTO: UserJoinDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .join(userJoinDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 이메일, 암호를 입력하여 로그인합니다
     * @summary 로그인
     * @param {UserLoginDTO} userLoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(
      userLoginDTO: UserLoginDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .login(userLoginDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * 로그아웃을 합니다.
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .logout(options)
        .then(request => request(axios, basePath));
    },
    /**
     * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resignAccessTokenByCookie(
      refreshToken: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .resignAccessTokenByCookie(refreshToken, options)
        .then(request => request(axios, basePath));
    },
    /**
     * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
     * @summary 토큰 재발급
     * @param {string} authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resignAccessTokenByHeader(
      authorization: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .resignAccessTokenByHeader(authorization, options)
        .then(request => request(axios, basePath));
    },
    /**
     * UserId를 이용해 소개글을 변경합니다
     * @summary 소개글 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateDescription(
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .updateDescription(userId, userChangeInfoDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
     * @summary 닉네임 변경
     * @param {string} userId
     * @param {UserChangeInfoDTO} userChangeInfoDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNickname(
      userId: string,
      userChangeInfoDTO: UserChangeInfoDTO,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .updateNickname(userId, userChangeInfoDTO, options)
        .then(request => request(axios, basePath));
    }
  };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
  /**
   * UserId를 이용해 비밀번호를 변경합니다
   * @summary 비밀번호 변경
   * @param {string} userId
   * @param {ChangePasswordDTO} changePasswordDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public changePassword(
    userId: string,
    changePasswordDTO: ChangePasswordDTO,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .changePassword(userId, changePasswordDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * UserId를 이용해 프로필 사진을 변경합니다
   * @summary 프로필 사진 변경
   * @param {string} userId
   * @param {File} [multipartFile]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public changeProfile(
    userId: string,
    multipartFile?: File,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .changeProfile(userId, multipartFile, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * UserId를 이용해 회원정보를 삭제합니다
   * @summary 회원 탈퇴
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
    return UserControllerApiFp(this.configuration)
      .deleteUser(userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * UserId를 이용해 회원정보를 조회합니다
   * @summary 회원 정보 조회
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public findMyInformation(userId: string, options?: RawAxiosRequestConfig) {
    return UserControllerApiFp(this.configuration)
      .findMyInformation(userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 이메일, 암호, 닉네임을 입력하여 회원가입을 합니다
   * @summary 회원가입
   * @param {UserJoinDTO} userJoinDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public join(userJoinDTO: UserJoinDTO, options?: RawAxiosRequestConfig) {
    return UserControllerApiFp(this.configuration)
      .join(userJoinDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 이메일, 암호를 입력하여 로그인합니다
   * @summary 로그인
   * @param {UserLoginDTO} userLoginDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public login(userLoginDTO: UserLoginDTO, options?: RawAxiosRequestConfig) {
    return UserControllerApiFp(this.configuration)
      .login(userLoginDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 로그아웃을 합니다.
   * @summary 로그아웃
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return UserControllerApiFp(this.configuration)
      .logout(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * (현재미구현)쿠키에 담긴 refresh토큰을 이용해 access토큰을 재발급합니다
   * @summary 토큰 재발급
   * @param {string} refreshToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public resignAccessTokenByCookie(
    refreshToken: string,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .resignAccessTokenByCookie(refreshToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * HTTP헤더에 담긴 refresh_token을 이용해 access_token을 재발급합니다
   * @summary 토큰 재발급
   * @param {string} authorization
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public resignAccessTokenByHeader(
    authorization: string,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .resignAccessTokenByHeader(authorization, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * UserId를 이용해 소개글을 변경합니다
   * @summary 소개글 변경
   * @param {string} userId
   * @param {UserChangeInfoDTO} userChangeInfoDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateDescription(
    userId: string,
    userChangeInfoDTO: UserChangeInfoDTO,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .updateDescription(userId, userChangeInfoDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * UserId를 이용해 닉네임을 변경합니다(도메인 규칙 : 2~10자 사이의 한글,영어소문자,숫자만)
   * @summary 닉네임 변경
   * @param {string} userId
   * @param {UserChangeInfoDTO} userChangeInfoDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateNickname(
    userId: string,
    userChangeInfoDTO: UserChangeInfoDTO,
    options?: RawAxiosRequestConfig
  ) {
    return UserControllerApiFp(this.configuration)
      .updateNickname(userId, userChangeInfoDTO, options)
      .then(request => request(this.axios, this.basePath));
  }
}
